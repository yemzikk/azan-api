<!DOCTYPE html>
<html lang="en">
  <head>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-LC24F79QZ5"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-LC24F79QZ5");
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Prayer Times Dashboard</title>
    <!-- SEO Meta Tags -->
    <meta
      name="description"
      content="Free Prayer Times API for Kerala locations. Get accurate daily, monthly, and yearly Islamic prayer schedules via REST API. Developer-friendly with JSON responses."
    />
    <meta
      name="keywords"
      content="prayer times api, azan api, islamic api, salah times api, kerala prayer api, muslim developer tools, prayer schedule api, rest api, json prayer times, free islamic api, azan data, prayer times json, salat api, masjid api, mosque times api"
    />
    <meta name="author" content="https://azan-api.yemzikk.in/dashboard/" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://azan-api.yemzikk.in/dashboard/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://azan-api.yemzikk.in/dashboard/" />
    <meta
      property="og:title"
      content="Prayer Times API - Free Islamic Prayer Schedule API"
    />
    <meta
      property="og:description"
      content="Free REST API for accurate prayer times in Kerala. Get JSON data for daily, monthly, and yearly Islamic prayer schedules. Perfect for developers building Islamic apps."
    />
    <meta
      property="og:image"
      content="https://azan-api.yemzikk.in/prayer-time.png"
    />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://azan-api.yemzikk.in/dashboard/" />
    <meta
      name="twitter:title"
      content="Prayer Times API - Free Islamic Prayer Schedule API"
    />
    <meta
      name="twitter:description"
      content="Free REST API for accurate prayer times in Kerala. Get JSON data for daily, monthly, and yearly Islamic prayer schedules. Perfect for developers building Islamic apps."
    />
    <meta
      name="twitter:image"
      content="https://azan-api.yemzikk.in/prayer-time.png"
    />

    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="favicon/android-chrome-192x192.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="favicon/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="favicon/favicon-16x16.png"
    />
    <link rel="manifest" href="favicon/site.webmanifest" />

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Prayer Times API",
        "url": "https://azan-api.yemzikk.in/",
        "description": "Free REST API for accurate prayer times in Kerala. Get JSON data for daily, monthly, and yearly Islamic prayer schedules. Perfect for developers building Islamic apps.",
        "applicationCategory": "DeveloperApplication",
        "operatingSystem": "All",
        "image": "https://azan-api.yemzikk.in/prayer-time.png",
        "author": {
          "@type": "Organization",
          "name": "azan-api.yemzikk.in"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        }
      }
    </script>

    <script src="https://cdn.tailwindcss.com"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <style>
      * {
        font-family: "Inter", sans-serif;
      }

      body {
        background: linear-gradient(
          135deg,
          #0f4c3a 0%,
          #1a5f4a 50%,
          #2d8659 100%
        );
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(255, 255, 255, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(255, 255, 255, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 40%,
            rgba(255, 255, 255, 0.04) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 60% 20%,
            rgba(255, 255, 255, 0.06) 0%,
            transparent 40%
          ),
          radial-gradient(
            circle at 10% 70%,
            rgba(255, 255, 255, 0.06) 0%,
            transparent 40%
          );
        pointer-events: none;
        animation: backgroundShift 20s ease-in-out infinite;
      }

      @keyframes backgroundShift {
        0%,
        100% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
        }
      }

      .glass-morphism {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(212, 175, 55, 0.2);
        box-shadow: 0 8px 32px 0 rgba(15, 76, 58, 0.2);
      }

      .glass-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(212, 175, 55, 0.25);
        box-shadow: 0 20px 40px rgba(15, 76, 58, 0.15);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .glass-card:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 30px 60px rgba(15, 76, 58, 0.2);
        background: rgba(255, 255, 255, 1);
        border-color: rgba(212, 175, 55, 0.4);
      }

      .prayer-card {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.92),
          rgba(255, 255, 255, 0.75)
        );
        backdrop-filter: blur(20px);
        border: 1px solid rgba(212, 175, 55, 0.3);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      .prayer-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #d4af37, #f4d03f);
        transform: scaleX(0);
        transition: transform 0.3s ease;
      }

      .prayer-card:hover::before {
        transform: scaleX(1);
      }

      .prayer-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 25px 50px rgba(15, 76, 58, 0.15);
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 1),
          rgba(255, 255, 255, 0.95)
        );
        border-color: rgba(212, 175, 55, 0.5);
      }

      .prayer-card.active {
        background: linear-gradient(145deg, #1a5f4a, #2d8659);
        color: white;
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 20px 40px rgba(26, 95, 74, 0.4);
        border-color: rgba(212, 175, 55, 0.6);
      }

      .prayer-card.active::before {
        background: rgba(212, 175, 55, 0.8);
        transform: scaleX(1);
      }

      .period-btn {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(212, 175, 55, 0.25);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 600;
      }

      .period-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(212, 175, 55, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .period-btn:hover::before {
        left: 100%;
      }

      .period-btn:hover {
        transform: translateY(-2px);
        background: rgba(212, 175, 55, 0.2);
        box-shadow: 0 10px 25px rgba(15, 76, 58, 0.2);
        color: white;
        border-color: rgba(212, 175, 55, 0.5);
      }

      .period-btn.active {
        background: rgba(212, 175, 55, 0.9);
        color: #0f4c3a;
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(212, 175, 55, 0.3);
        border-color: rgba(212, 175, 55, 0.8);
        font-weight: 700;
      }

      .floating-element {
        animation: float 8s ease-in-out infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px) translateX(0px) rotate(0deg);
          opacity: 0.6;
        }
        25% {
          transform: translateY(-15px) translateX(5px) rotate(90deg);
          opacity: 0.8;
        }
        50% {
          transform: translateY(-25px) translateX(-5px) rotate(180deg);
          opacity: 0.4;
        }
        75% {
          transform: translateY(-10px) translateX(8px) rotate(270deg);
          opacity: 0.7;
        }
      }

      .fade-in {
        animation: fadeIn 0.8s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-in {
        animation: slideIn 0.6s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .prayer-glow {
        animation: prayerPulse 4s ease-in-out infinite;
      }

      @keyframes prayerPulse {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }
        50% {
          box-shadow: 0 0 30px rgba(212, 175, 55, 0.4),
            0 0 40px rgba(26, 95, 74, 0.2);
        }
      }

      .prayer-time-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 1rem;
      }

      @media (min-width: 640px) {
        .prayer-time-grid {
          grid-template-columns: repeat(3, 1fr);
          gap: 1.5rem;
        }
      }

      @media (min-width: 1024px) {
        .prayer-time-grid {
          grid-template-columns: repeat(6, 1fr);
          gap: 1.5rem;
        }
      }

      .select-wrapper {
        position: relative;
      }

      .select-wrapper::after {
        content: "\f107";
        font-family: "Font Awesome 6 Free";
        font-weight: 900;
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        color: #1a5f4a;
        transition: transform 0.3s ease;
      }

      .select-wrapper:hover::after {
        transform: translateY(-50%) scale(1.1);
      }

      select {
        appearance: none;
        background: rgba(255, 255, 255, 0.92);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(212, 175, 55, 0.3);
        transition: all 0.3s ease;
      }

      select:focus {
        background: rgba(255, 255, 255, 1);
        border-color: #1a5f4a;
        box-shadow: 0 0 0 3px rgba(26, 95, 74, 0.15);
        outline: none;
      }

      /* Select option styling */
      select option[value="auto-detect"] {
        background: linear-gradient(135deg, #d4af37, #f4d03f);
        color: #0f4c3a;
        font-weight: bold;
      }

      select option:disabled {
        color: rgba(128, 128, 128, 0.6);
        font-style: italic;
      }

      .time-highlight {
        background: linear-gradient(135deg, #1a5f4a, #124a39);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-weight: 700;
      }

      .pulse-ring {
        animation: pulse-ring 2s infinite;
      }

      @keyframes pulse-ring {
        0% {
          transform: scale(0.33);
        }
        40%,
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0;
          transform: scale(1.2);
        }
      }

      .loading-dots {
        display: inline-block;
        position: relative;
        width: 80px;
        height: 80px;
      }

      .loading-dots div {
        position: absolute;
        top: 33px;
        width: 13px;
        height: 13px;
        border-radius: 50%;
        background: #d4af37;
        animation-timing-function: cubic-bezier(0, 1, 1, 0);
      }

      .loading-dots div:nth-child(1) {
        left: 8px;
        animation: loading1 0.6s infinite;
      }

      .loading-dots div:nth-child(2) {
        left: 8px;
        animation: loading2 0.6s infinite;
      }

      .loading-dots div:nth-child(3) {
        left: 32px;
        animation: loading2 0.6s infinite;
      }

      .loading-dots div:nth-child(4) {
        left: 56px;
        animation: loading3 0.6s infinite;
      }

      @keyframes loading1 {
        0% {
          transform: scale(0);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes loading3 {
        0% {
          transform: scale(1);
        }
        100% {
          transform: scale(0);
        }
      }

      @keyframes loading2 {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(24px, 0);
        }
      }

      .moroccan-pattern {
        background: linear-gradient(
          135deg,
          #0f4c3a 0%,
          #1a5f4a 50%,
          #2d8659 100%
        );
        background-image: 
          /* Islamic Star Pattern */ radial-gradient(
            circle at 25px 25px,
            rgba(212, 175, 55, 0.08) 2px,
            transparent 2px
          ),
          radial-gradient(
            circle at 75px 75px,
            rgba(212, 175, 55, 0.06) 2px,
            transparent 2px
          ),
          /* Geometric Grid */
            repeating-linear-gradient(
              45deg,
              rgba(212, 175, 55, 0.02) 0px,
              rgba(212, 175, 55, 0.02) 1px,
              transparent 1px,
              transparent 12px
            ),
          repeating-linear-gradient(
            -45deg,
            rgba(212, 175, 55, 0.02) 0px,
            rgba(212, 175, 55, 0.02) 1px,
            transparent 1px,
            transparent 12px
          ),
          /* Hexagonal Pattern */
            linear-gradient(
              60deg,
              rgba(212, 175, 55, 0.01) 25%,
              transparent 25.5%,
              transparent 75%,
              rgba(212, 175, 55, 0.01) 75.5%,
              rgba(212, 175, 55, 0.01)
            ),
          linear-gradient(
            -60deg,
            rgba(212, 175, 55, 0.01) 25%,
            transparent 25.5%,
            transparent 75%,
            rgba(212, 175, 55, 0.01) 75.5%,
            rgba(212, 175, 55, 0.01)
          );
        background-size: 50px 50px, 100px 100px, 24px 24px, 24px 24px, 60px 36px,
          60px 36px;
        background-position: 0 0, 25px 25px, 0 0, 12px 12px, 0 0, 30px 18px;
      }

      /* Mobile optimizations */
      @media (max-width: 640px) {
        .prayer-time-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 1rem;
        }

        .glass-card {
          padding: 1rem;
        }

        .floating-element {
          display: none;
        }
      }

      /* Smooth scrolling */
      html {
        scroll-behavior: smooth;
      }

      /* Focus states for accessibility */
      button:focus,
      select:focus {
        outline: 2px solid rgba(212, 175, 55, 0.6);
        outline-offset: 2px;
      }

      /* Loading animation enhancement */
      .pulse-ring {
        position: relative;
      }

      .pulse-ring::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: rgba(212, 175, 55, 0.4);
        transform: translate(-50%, -50%);
        animation: pulse-ring 2s infinite;
      }

      /* Enhanced hover effects */
      .glass-card:hover {
        background: rgba(255, 255, 255, 0.98);
        border-color: rgba(212, 175, 55, 0.5);
      }

      .prayer-card.active:hover {
        background: linear-gradient(145deg, #1a5f4a, #2d8659);
      }

      /* Nearby Locations Panel Styles */
      .custom-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: rgba(212, 175, 55, 0.6) rgba(255, 255, 255, 0.1);
      }

      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
      }

      .custom-scrollbar::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: rgba(212, 175, 55, 0.6);
        border-radius: 3px;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: rgba(212, 175, 55, 0.8);
      }

      .nearby-location-card {
        backdrop-filter: blur(10px);
        animation: slideInUp 0.3s ease-out;
      }

      .nearby-location-card:nth-child(odd) {
        animation-delay: 0.05s;
      }

      .nearby-location-card:nth-child(even) {
        animation-delay: 0.1s;
      }

      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .nearby-location-card:hover {
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      }

      /* Auto-detection success animation */
      .detection-success {
        animation: successPulse 0.6s ease-out;
      }

      @keyframes successPulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
        }
      }
    </style>
  </head>
  <body class="min-h-screen moroccan-pattern">
    <!-- Dark Horizon Glow Background -->
    <div class="min-h-screen w-full relative">
      <div
        class="absolute inset-0 z-0"
        style="
          background: radial-gradient(
            125% 125% at 50% 90%,
            #0a2e1f 40%,
            #1a5f4a 100%
          );
        "
      ></div>

      <div
        class="relative z-20 container mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8 lg:py-12"
      >
        <!-- Header -->
        <div class="text-center mb-8 sm:mb-12 fade-in">
          <div class="mb-6">
            <div
              class="inline-flex items-center justify-center w-20 h-20 sm:w-24 sm:h-24 glass-morphism rounded-full mb-6"
            >
              <i class="fas fa-mosque text-3xl sm:text-4xl text-white"></i>
            </div>
          </div>
          <h1
            class="text-4xl sm:text-5xl lg:text-6xl font-bold text-white mb-4 tracking-tight"
          >
            Prayer Times
            <span
              class="block text-2xl sm:text-3xl lg:text-4xl font-light text-white text-opacity-90 mt-2"
              >Dashboard</span
            >
          </h1>
          <p
            class="text-lg sm:text-xl text-white text-opacity-80 max-w-2xl mx-auto leading-relaxed"
          >
            Track Islamic prayer schedules with precision and beauty across
            locations and time periods
          </p>
        </div>

        <!-- Controls -->
        <div
          class="glass-morphism rounded-3xl shadow-2xl p-6 sm:p-8 mb-8 sm:mb-12 slide-in"
        >
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8">
            <!-- Location Selector -->
            <div class="space-y-3">
              <label
                class="flex items-center gap-3 text-white font-semibold text-sm sm:text-base"
              >
                <div
                  class="flex items-center justify-center w-8 h-8 bg-white bg-opacity-20 rounded-lg"
                >
                  <i class="fas fa-map-marker-alt text-white text-sm"></i>
                </div>
                Select Location
              </label>
              <div class="select-wrapper">
                <select
                  id="location"
                  class="w-full px-4 sm:px-6 py-3 sm:py-4 rounded-2xl text-gray-800 font-medium text-sm sm:text-base cursor-pointer focus:ring-4 focus:ring-white focus:ring-opacity-20"
                ></select>
              </div>
            </div>

            <!-- Period Selector -->
            <div class="space-y-3">
              <label
                class="flex items-center gap-3 text-white font-semibold text-sm sm:text-base"
              >
                <div
                  class="flex items-center justify-center w-8 h-8 bg-white bg-opacity-20 rounded-lg"
                >
                  <i class="fas fa-calendar-alt text-white text-sm"></i>
                </div>
                Select Time Period
              </label>
              <div class="flex gap-3" id="period-buttons"></div>
            </div>
          </div>
        </div>

        <!-- Loader -->
        <div
          id="loading"
          class="hidden glass-morphism rounded-3xl shadow-2xl p-8 sm:p-12"
        >
          <div class="flex flex-col items-center justify-center space-y-6">
            <div class="loading-dots">
              <div></div>
              <div></div>
              <div></div>
              <div></div>
            </div>
            <p class="text-white text-lg sm:text-xl font-medium">
              Loading prayer data...
            </p>
          </div>
        </div>

        <!-- Error -->
        <div
          id="error"
          class="hidden glass-morphism rounded-3xl p-6 sm:p-8 border border-red-200"
        >
          <div class="flex items-center gap-4">
            <div
              class="flex items-center justify-center w-12 h-12 bg-red-100 rounded-full"
            >
              <i class="fas fa-exclamation-triangle text-red-600 text-xl"></i>
            </div>
            <p
              class="text-red-600 font-semibold text-sm sm:text-base flex-1"
            ></p>
          </div>
        </div>

        <!-- Prayer Data -->
        <div id="prayer-data" class="hidden fade-in"></div>

        <!-- Footer -->
        <footer class="text-center mt-12 sm:mt-16 fade-in">
          <div
            class="glass-morphism rounded-2xl p-6 sm:p-8 border border-white border-opacity-20"
          >
            <div
              class="flex flex-col sm:flex-row items-center justify-center gap-4 sm:gap-8 text-white"
            >
              <div class="flex items-center gap-2">
                <i class="fas fa-mosque text-lg text-white"></i>
                <span class="font-semibold text-white">Prayer Times API</span>
              </div>
              <div class="flex items-center gap-2">
                <i class="fas fa-code text-sm text-white"></i>
                <span class="text-sm font-medium text-white"
                  >Built with precision & care</span
                >
              </div>
              <div class="flex items-center gap-2">
                <i class="fas fa-heart text-red-300 text-sm"></i>
                <span class="text-sm font-medium text-white"
                  >Serving the Ummah</span
                >
              </div>
            </div>
          </div>
        </footer>
      </div>

      <script>
        const periods = [
          { value: "today", label: "Today" },
          { value: "month", label: "This Month" },
          { value: "year", label: "This Year" },
        ];

        let locations = [];
        let selectedLocation = null;
        let selectedPeriod = "today";
        let geocodeCache = new Map(); // Will be replaced with advanced cache
        let isAutoDetecting = false;

        // 🚀 ADVANCED CACHING & PERFORMANCE SYSTEM

        // Enhanced cache with metadata and compression
        class AdvancedLocationCache {
          constructor() {
            this.cache = new Map();
            this.metadata = new Map(); // Store cache metadata
            this.compressionEnabled = this.supportsCompression();
            this.maxCacheSize = 500; // Maximum cached locations
            this.cacheVersion = "2.0"; // For cache invalidation
            this.init();
          }

          init() {
            this.loadFromStorage();
            this.setupAutoCleanup();
            console.log(
              `🏎️ Advanced cache initialized: ${this.cache.size} locations loaded`
            );
          }

          supportsCompression() {
            try {
              return "CompressionStream" in window || "pako" in window;
            } catch {
              return false;
            }
          }

          async set(key, value, metadata = {}) {
            const entry = {
              data: value,
              timestamp: Date.now(),
              hits: 0,
              lastAccessed: Date.now(),
              size: JSON.stringify(value).length,
              ...metadata,
            };

            this.cache.set(key, value);
            this.metadata.set(key, entry);

            // Automatic cache size management
            if (this.cache.size > this.maxCacheSize) {
              await this.evictLeastUsed();
            }

            // Async persistence
            this.persistToStorage();
          }

          get(key) {
            if (this.cache.has(key)) {
              const metadata = this.metadata.get(key);
              if (metadata) {
                metadata.hits++;
                metadata.lastAccessed = Date.now();
              }
              return this.cache.get(key);
            }
            return null;
          }

          has(key) {
            return this.cache.has(key);
          }

          async evictLeastUsed() {
            const entries = Array.from(this.metadata.entries()).sort((a, b) => {
              // Sort by frequency and recency
              const scoreA =
                a[1].hits * 0.7 + (Date.now() - a[1].lastAccessed) * -0.3;
              const scoreB =
                b[1].hits * 0.7 + (Date.now() - b[1].lastAccessed) * -0.3;
              return scoreA - scoreB;
            });

            const toEvict = entries.slice(
              0,
              Math.floor(this.maxCacheSize * 0.2)
            ); // Remove 20%

            for (const [key] of toEvict) {
              this.cache.delete(key);
              this.metadata.delete(key);
            }

            console.log(`🧹 Cache cleanup: removed ${toEvict.length} entries`);
          }

          async loadFromStorage() {
            try {
              const [cacheData, metadataData, version] = await Promise.all([
                this.getStorageItem("azanLocationCacheV2"),
                this.getStorageItem("azanLocationMetadataV2"),
                this.getStorageItem("azanLocationCacheVersionV2"),
              ]);

              if (version !== this.cacheVersion) {
                console.log("🔄 Cache version mismatch, clearing old cache");
                this.clearStorage();
                return;
              }

              if (cacheData && metadataData) {
                const cacheEntries = JSON.parse(cacheData);
                const metadataEntries = JSON.parse(metadataData);

                this.cache = new Map(cacheEntries);
                this.metadata = new Map(metadataEntries);

                console.log(
                  `� Loaded ${this.cache.size} locations from advanced cache`
                );
              }
            } catch (error) {
              console.warn("Failed to load cache:", error);
              this.clearStorage();
            }
          }

          async persistToStorage() {
            try {
              const cacheEntries = Array.from(this.cache.entries());
              const metadataEntries = Array.from(this.metadata.entries());

              await Promise.all([
                this.setStorageItem(
                  "azanLocationCacheV2",
                  JSON.stringify(cacheEntries)
                ),
                this.setStorageItem(
                  "azanLocationMetadataV2",
                  JSON.stringify(metadataEntries)
                ),
                this.setStorageItem(
                  "azanLocationCacheVersionV2",
                  this.cacheVersion
                ),
              ]);
            } catch (error) {
              console.warn("Failed to persist cache:", error);
            }
          }

          async getStorageItem(key) {
            return localStorage.getItem(key);
          }

          async setStorageItem(key, value) {
            localStorage.setItem(key, value);
          }

          setupAutoCleanup() {
            // Clean up expired entries every 5 minutes
            setInterval(() => {
              this.cleanupExpired();
            }, 5 * 60 * 1000);
          }

          cleanupExpired() {
            const now = Date.now();
            const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
            let cleaned = 0;

            for (const [key, metadata] of this.metadata.entries()) {
              if (now - metadata.timestamp > maxAge) {
                this.cache.delete(key);
                this.metadata.delete(key);
                cleaned++;
              }
            }

            if (cleaned > 0) {
              console.log(`🧹 Cleaned ${cleaned} expired cache entries`);
              this.persistToStorage();
            }
          }

          clearStorage() {
            [
              "azanLocationCacheV2",
              "azanLocationMetadataV2",
              "azanLocationCacheVersionV2",
            ].forEach((key) => {
              localStorage.removeItem(key);
            });
            this.cache.clear();
            this.metadata.clear();
          }

          getStats() {
            const totalSize = Array.from(this.metadata.values()).reduce(
              (sum, meta) => sum + meta.size,
              0
            );

            return {
              size: this.cache.size,
              totalSizeKB: Math.round(totalSize / 1024),
              hitRate: this.calculateHitRate(),
              oldestEntry: this.getOldestEntry(),
              mostUsed: this.getMostUsedEntry(),
            };
          }

          calculateHitRate() {
            const entries = Array.from(this.metadata.values());
            if (entries.length === 0) return 0;

            const totalHits = entries.reduce((sum, meta) => sum + meta.hits, 0);
            return totalHits / entries.length;
          }

          getOldestEntry() {
            let oldest = null;
            let oldestTime = Date.now();

            for (const [key, metadata] of this.metadata.entries()) {
              if (metadata.timestamp < oldestTime) {
                oldestTime = metadata.timestamp;
                oldest = key;
              }
            }

            return oldest;
          }

          getMostUsedEntry() {
            let mostUsed = null;
            let maxHits = 0;

            for (const [key, metadata] of this.metadata.entries()) {
              if (metadata.hits > maxHits) {
                maxHits = metadata.hits;
                mostUsed = key;
              }
            }

            return { key: mostUsed, hits: maxHits };
          }
        }

        // Performance monitoring and optimization
        class PerformanceMonitor {
          constructor() {
            this.metrics = new Map();
            this.enabled = true;
          }

          startTiming(operation) {
            if (!this.enabled) return null;

            const id = `${operation}_${Date.now()}_${Math.random()}`;
            this.metrics.set(id, {
              operation,
              startTime: performance.now(),
              startMemory: this.getMemoryUsage(),
            });
            return id;
          }

          endTiming(id) {
            if (!this.enabled || !this.metrics.has(id)) return null;

            const metric = this.metrics.get(id);
            const endTime = performance.now();
            const endMemory = this.getMemoryUsage();

            const result = {
              operation: metric.operation,
              duration: endTime - metric.startTime,
              memoryDelta: endMemory - metric.startMemory,
              timestamp: new Date().toISOString(),
            };

            this.metrics.delete(id);
            this.logPerformance(result);
            return result;
          }

          getMemoryUsage() {
            try {
              return performance.memory ? performance.memory.usedJSHeapSize : 0;
            } catch {
              return 0;
            }
          }

          logPerformance(result) {
            if (result.duration > 1000) {
              // Log operations > 1 second
              console.log(
                `⚡ Performance: ${
                  result.operation
                } took ${result.duration.toFixed(2)}ms`
              );
            }
          }

          getAverageTime(operation) {
            // This would track historical performance data
            return 0;
          }
        }

        // Initialize advanced systems
        const advancedCache = new AdvancedLocationCache();
        const performanceMonitor = new PerformanceMonitor();

        // Replace simple cache with advanced cache
        geocodeCache = advancedCache;

        // Enhanced cache utilities with advanced features
        window.azanCache = {
          stats: () => advancedCache.getStats(),
          clear: () => advancedCache.clearStorage(),
          size: () => advancedCache.cache.size,
          performance: () => performanceMonitor.metrics,
          evict: () => advancedCache.evictLeastUsed(),

          // Advanced debugging utilities
          inspect: (key) => ({
            cached: advancedCache.has(key),
            metadata: advancedCache.metadata.get(key),
            data: advancedCache.get(key),
          }),

          // Cache health check
          health: () => {
            const stats = advancedCache.getStats();
            return {
              healthy: stats.size > 0 && stats.hitRate > 0.5,
              recommendations:
                stats.size === 0
                  ? ["Cache is empty"]
                  : stats.hitRate < 0.3
                  ? ["Low hit rate - consider cache warming"]
                  : ["Cache is performing well"],
            };
          },
        };

        const locationSelect = document.getElementById("location");
        const periodButtonsDiv = document.getElementById("period-buttons");
        const loadingDiv = document.getElementById("loading");
        const errorDiv = document.getElementById("error");
        const prayerDataDiv = document.getElementById("prayer-data");

        // 🚀 WORLD-CLASS AUTO-DETECTION OPTIMIZATION

        // Advanced location similarity scoring for better matches
        class LocationMatcher {
          static levenshteinDistance(a, b) {
            const dp = Array(a.length + 1)
              .fill()
              .map(() => Array(b.length + 1).fill(0));

            for (let i = 0; i <= a.length; i++) dp[i][0] = i;
            for (let j = 0; j <= b.length; j++) dp[0][j] = j;

            for (let i = 1; i <= a.length; i++) {
              for (let j = 1; j <= b.length; j++) {
                if (a[i - 1] === b[j - 1]) {
                  dp[i][j] = dp[i - 1][j - 1];
                } else {
                  dp[i][j] =
                    1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
                }
              }
            }
            return dp[a.length][b.length];
          }

          static similarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            if (longer.length === 0) return 1.0;

            const distance = this.levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
          }

          static fuzzyMatch(query, candidates) {
            return candidates
              .map((candidate) => ({
                candidate,
                score: this.similarity(
                  query.toLowerCase(),
                  candidate.toLowerCase()
                ),
              }))
              .filter((item) => item.score > 0.6)
              .sort((a, b) => b.score - a.score);
          }
        }

        // Smart location preprocessing with context awareness
        class LocationProcessor {
          static cleanLocationName(locationName, attempt = 1) {
            const stopWords = [
              "HANAFI",
              "SHAFI",
              "SAMASTHA",
              "MARKAZ",
              "CHANDRIKA",
              "ALBUSTHAN",
              "SUNNI",
              "JAMIYYATHUL",
              "MUALLIMEEN",
              "Assembly",
              "Constituency",
              "District",
              "Taluk",
              "Corporation",
              "Municipality",
              "Panchayat",
              "Town",
              "City",
              "Village",
              "North",
              "South",
              "East",
              "West",
              "Market_Pally",
              "Eriyad_Special",
              "Luhar",
              "KKPJ",
              "EKM",
              "UK",
              "TVM",
            ];

            const timePatterns = [
              /12:40_Fixed/gi,
              /ROUND_FIGURE/gi,
              /ORIGIN_80/gi,
              /Magrib_Isha/gi,
              /OG/gi,
              /standard_to_thambaanur/gi,
              /PAIPPAD_ISLAMIC_FINDER/gi,
              /PADUBIDRI/gi,
              /\b\d{4}\b/g,
            ];

            let query = locationName.replace(/_/g, " ");

            // Remove Islamic/administrative terms
            stopWords.forEach((word) => {
              query = query.replace(new RegExp(word, "gi"), "");
            });

            // Remove time patterns
            timePatterns.forEach((pattern) => {
              query = query.replace(pattern, "");
            });

            // Clean punctuation and extra spaces
            query = query
              .replace(/\([^)]*\)/g, "")
              .replace(/[-_]+/g, " ")
              .replace(/\s+/g, " ")
              .trim();

            // Multi-attempt strategy
            if (attempt === 2) {
              const parts = locationName.split("_");
              query = parts[0].replace(/[^a-zA-Z]/g, "");
            } else if (attempt === 3) {
              const parts = locationName.split("_");
              query =
                parts.length > 1 ? parts[1].replace(/[^a-zA-Z]/g, "") : "";
            }

            return query.length >= 3 ? query : null;
          }

          static generateSearchVariants(cleanedName) {
            const variants = [
              `${cleanedName}, Kerala, India`,
              `${cleanedName}, Kerala`,
              `${cleanedName} Kerala`,
              cleanedName,
            ];

            // Add common suffixes for Kerala locations
            const suffixes = ["Panchayat", "Municipality", "Corporation"];
            suffixes.forEach((suffix) => {
              variants.push(`${cleanedName} ${suffix}, Kerala, India`);
            });

            return [...new Set(variants)]; // Remove duplicates
          }
        }

        // Advanced geocoding with multiple fallback strategies
        async function geocodeLocation(locationName, attempt = 1) {
          // Check cache first
          if (geocodeCache.has(locationName)) {
            return geocodeCache.get(locationName);
          }

          try {
            const cleanedName = LocationProcessor.cleanLocationName(
              locationName,
              attempt
            );
            if (!cleanedName) return null;

            const searchVariants =
              LocationProcessor.generateSearchVariants(cleanedName);

            // Try each search variant until we find results
            for (const searchQuery of searchVariants) {
              const coords = await this.tryGeocode(searchQuery, attempt);
              if (coords) {
                // Cache successful result with advanced caching
                await geocodeCache.set(locationName, coords, {
                  source: "nominatim",
                  quality: coords.confidence || 0.8,
                  searchQuery: searchQuery,
                });
                return coords;
              }
            }

            // Recursive retry with next attempt
            if (attempt < 3) {
              return await geocodeLocation(locationName, attempt + 1);
            }

            return null;
          } catch (error) {
            console.warn(
              `Geocoding attempt ${attempt} failed for ${locationName}:`,
              error
            );
            if (attempt < 3) {
              return await geocodeLocation(locationName, attempt + 1);
            }
            return null;
          }
        }

        // Optimized geocoding with intelligent result selection
        async function tryGeocode(searchQuery, attempt) {
          const urls = [
            // Primary: Nominatim with Kerala focus (using q parameter only)
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
              searchQuery
            )}&limit=5&countrycodes=in`,
            // Fallback: General India search
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
              searchQuery
            )}&limit=3&countrycodes=in`,
          ];

          // Exponential backoff delay
          const delay = Math.min(200 * Math.pow(1.5, attempt - 1), 2000);
          await new Promise((resolve) => setTimeout(resolve, delay));

          for (const url of urls) {
            try {
              const response = await fetch(url, {
                headers: {
                  "User-Agent": "Prayer Times Dashboard (contact@azantimes.in)",
                },
                signal: AbortSignal.timeout(8000), // 8 second timeout
              });

              if (!response.ok) {
                console.warn(
                  `Geocoding API returned ${response.status} for: ${url}`
                );
                continue;
              }

              const data = await response.json();

              // Check for API error responses
              if (data.error) {
                console.warn(
                  `Geocoding API error: ${data.error.message} for: ${url}`
                );
                continue;
              }

              if (data.length > 0) {
                // Intelligent result selection
                const bestMatch = this.selectBestGeocodingResult(
                  data,
                  searchQuery
                );
                if (bestMatch) {
                  return {
                    lat: parseFloat(bestMatch.lat),
                    lon: parseFloat(bestMatch.lon),
                    confidence: bestMatch.confidence || 0.8,
                  };
                }
              }
            } catch (error) {
              console.warn(`Geocoding URL failed: ${url}`, error);
              continue;
            }
          }

          return null;
        }

        // Smart result selection based on relevance scoring
        function selectBestGeocodingResult(results, originalQuery) {
          const scoredResults = results.map((result) => {
            let score = 0;
            const displayName = result.display_name.toLowerCase();
            const query = originalQuery.toLowerCase();

            // Kerala preference (highest priority)
            if (displayName.includes("kerala")) score += 100;

            // Exact name match
            if (displayName.includes(query.split(",")[0].trim())) score += 50;

            // Location type preferences
            if (result.type === "city" || result.type === "town") score += 30;
            else if (result.type === "village") score += 20;
            else if (result.type === "administrative") score += 10;

            // Importance score from OSM
            if (result.importance) score += result.importance * 20;

            // Penalize very generic results
            if (
              displayName.includes("india") &&
              !displayName.includes("kerala")
            )
              score -= 10;

            return { ...result, score, confidence: Math.min(score / 100, 1) };
          });

          // Return highest scoring result above threshold
          const bestResult = scoredResults
            .filter((r) => r.score > 20)
            .sort((a, b) => b.score - a.score)[0];

          return bestResult || results[0]; // Fallback to first result
        }

        // Haversine formula for calculating distance
        function getDistance(lat1, lon1, lat2, lon2) {
          const R = 6371; // Earth's radius in kilometers
          const dLat = ((lat2 - lat1) * Math.PI) / 180;
          const dLon = ((lon2 - lon1) * Math.PI) / 180;
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
              Math.cos((lat2 * Math.PI) / 180) *
              Math.sin(dLon / 2) *
              Math.sin(dLon / 2);
          return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // 🎯 NEXT-GENERATION AUTO-DETECTION ALGORITHM
        async function autoDetectLocation() {
          if (isAutoDetecting) return;
          isAutoDetecting = true;

          const timingId = performanceMonitor.startTiming("autoDetectLocation");
          progressTracker.start("Auto-detecting location", 5);

          try {
            showLoading("autodetect");
            progressTracker.step("Initializing location services");

            // Enhanced geolocation validation
            if (!navigator.geolocation) {
              throw new Error("Geolocation is not supported by this browser");
            }

            if (
              location.protocol !== "https:" &&
              location.hostname !== "localhost" &&
              location.hostname !== "127.0.0.1"
            ) {
              throw new Error("HTTPS connection required for geolocation");
            }

            progressTracker.step("Acquiring user position");
            // Get high-accuracy position with progressive fallback
            const position = await this.getOptimalUserPosition();
            const userLat = position.coords.latitude;
            const userLon = position.coords.longitude;
            const accuracy = position.coords.accuracy;

            console.log(
              `🎯 User location: ${userLat.toFixed(6)}, ${userLon.toFixed(
                6
              )} (±${accuracy}m)`
            );
            progressTracker.step("Processing location data", {
              lat: userLat,
              lon: userLon,
              accuracy,
            });

            // Smart location search with multiple strategies
            progressTracker.step("Finding nearest prayer location");
            const searchResult = await this.findNearestLocationIntelligent(
              userLat,
              userLon
            );

            if (searchResult.location) {
              progressTracker.step("Finalizing selection");
              await this.selectDetectedLocation(searchResult);

              const result = progressTracker.complete(searchResult);
              performanceMonitor.endTiming(timingId);

              console.log(
                `✅ Auto-detected: ${
                  searchResult.location.display
                } (${searchResult.location.dist.toFixed(1)}km, confidence: ${(
                  searchResult.confidence * 100
                ).toFixed(1)}%)`
              );
            } else {
              throw new Error("Could not find any nearby locations");
            }
          } catch (error) {
            console.error("🚫 Auto-detection error:", error);
            await this.handleAutoDetectionError(error);
            performanceMonitor.endTiming(timingId);
          } finally {
            isAutoDetecting = false;
            hideLoading();
          }
        }

        // Progressive geolocation with fallback strategies
        async function getOptimalUserPosition() {
          const strategies = [
            // High accuracy GPS
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 },
            // Balanced accuracy/speed
            { enableHighAccuracy: false, timeout: 8000, maximumAge: 60000 },
            // Network-based fallback
            { enableHighAccuracy: false, timeout: 15000, maximumAge: 300000 },
          ];

          for (let i = 0; i < strategies.length; i++) {
            try {
              const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(
                  resolve,
                  reject,
                  strategies[i]
                );
              });

              console.log(
                `📍 Position acquired using strategy ${i + 1} (accuracy: ±${
                  position.coords.accuracy
                }m)`
              );
              return position;
            } catch (error) {
              console.warn(`Strategy ${i + 1} failed:`, error.message);
              if (i === strategies.length - 1) throw error;
            }
          }
        }

        // Intelligent nearest location finder with multiple algorithms
        async function findNearestLocationIntelligent(userLat, userLon) {
          const strategies = [
            this.spatialIndexSearch, // Fastest: Pre-computed spatial index
            this.adaptiveBatchSearch, // Balanced: Smart batching
            this.comprehensiveSearch, // Fallback: Full search
          ];

          let bestResult = {
            location: null,
            confidence: 0,
            nearbyLocations: [],
          };

          for (const strategy of strategies) {
            try {
              const result = await strategy.call(this, userLat, userLon);
              if (result.confidence > bestResult.confidence) {
                bestResult = result;
              }

              // Collect nearby locations for display
              if (result.nearbyLocations && result.nearbyLocations.length > 0) {
                bestResult.nearbyLocations = result.nearbyLocations;
              }

              // Early termination if high confidence result found
              if (result.confidence > 0.85) {
                console.log(
                  `🎯 High-confidence result found with ${strategy.name}`
                );
                break;
              }
            } catch (error) {
              console.warn(`Strategy ${strategy.name} failed:`, error);
            }
          }

          return bestResult;
        }

        // Strategy 1: Spatial index search (fastest)
        async function spatialIndexSearch(userLat, userLon) {
          const GRID_SIZE = 0.1; // ~11km grid cells
          const gridKey = `${Math.floor(userLat / GRID_SIZE)}_${Math.floor(
            userLon / GRID_SIZE
          )}`;

          // Check if we have a spatial index for this region
          const spatialIndex = this.getSpatialIndex();
          const nearbyLocations = spatialIndex[gridKey] || [];

          if (nearbyLocations.length === 0) {
            return { location: null, confidence: 0 };
          }

          // Quick distance calculation for nearby locations
          let nearest = null;
          let minDist = Infinity;

          for (const locationData of nearbyLocations) {
            const dist = this.fastDistance(
              userLat,
              userLon,
              locationData.lat,
              locationData.lon
            );
            if (dist < minDist) {
              minDist = dist;
              nearest = locationData;
            }
          }

          return {
            location: nearest ? { ...nearest, dist: minDist } : null,
            confidence: nearest ? Math.min(0.9, 10 / minDist) : 0,
          };
        }

        // Strategy 2: Adaptive batch search (balanced)
        async function adaptiveBatchSearch(userLat, userLon) {
          const MAX_DISTANCE = 50; // km
          let nearest = null;
          let minDist = Infinity;
          let processed = 0;
          const total = locations.length;
          const nearbyLocations = []; // Collect all nearby locations

          // Dynamic batch sizing based on results
          let batchSize = 5;
          const maxBatchSize = 15;

          for (let i = 0; i < locations.length; i += batchSize) {
            const batch = locations.slice(i, i + batchSize);

            const promises = batch.map(async (locationDisplay) => {
              try {
                const locationName = locationDisplay.replace(/ /g, "_");
                const coords = await geocodeLocation(locationName);

                if (coords) {
                  const dist = this.getDistance(
                    userLat,
                    userLon,
                    coords.lat,
                    coords.lon
                  );
                  processed++;

                  const locationInfo = {
                    name: locationName,
                    display: locationDisplay,
                    lat: coords.lat,
                    lon: coords.lon,
                    dist: dist,
                  };

                  // Add to nearby locations if within range
                  if (dist <= MAX_DISTANCE) {
                    nearbyLocations.push(locationInfo);
                  }

                  if (dist < minDist && dist <= MAX_DISTANCE) {
                    minDist = dist;
                    nearest = locationInfo;
                  }
                }
                return dist;
              } catch (error) {
                return Infinity;
              }
            });

            const results = await Promise.all(promises);

            // Update progress with smart messaging
            this.updateSearchProgress(processed, total, nearest);

            // Early termination if very close location found
            const minBatchDist = Math.min(
              ...results.filter((d) => d !== Infinity)
            );
            if (minBatchDist < 2) {
              // Less than 2km
              console.log(
                `🎯 Very close location found (${minBatchDist.toFixed(
                  1
                )}km), stopping search`
              );
              break;
            }

            // Adaptive batch sizing
            const successRate =
              results.filter((d) => d !== Infinity).length / results.length;
            if (successRate > 0.7 && batchSize < maxBatchSize) {
              batchSize = Math.min(batchSize + 2, maxBatchSize);
            } else if (successRate < 0.3 && batchSize > 3) {
              batchSize = Math.max(batchSize - 1, 3);
            }

            // Smart delay based on performance
            const delay = results.length === batch.length ? 800 : 1200;
            if (i + batchSize < locations.length) {
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }

          // Sort nearby locations by distance
          nearbyLocations.sort((a, b) => a.dist - b.dist);

          const confidence = nearest
            ? Math.min(0.95, Math.max(0.3, 20 / nearest.dist))
            : 0;

          return {
            location: nearest,
            confidence,
            nearbyLocations: nearbyLocations.slice(0, 10), // Return top 10 nearest locations
          };
        }

        // Strategy 3: Comprehensive search (fallback)
        async function comprehensiveSearch(userLat, userLon) {
          // This is similar to the adaptive search but with more thorough coverage
          return await this.adaptiveBatchSearch(userLat, userLon);
        }

        // Fast distance calculation (Haversine optimized)
        function fastDistance(lat1, lon1, lat2, lon2) {
          const R = 6371; // Earth's radius in km
          const dLat = ((lat2 - lat1) * Math.PI) / 180;
          const dLon = ((lon2 - lon1) * Math.PI) / 180;
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
              Math.cos((lat2 * Math.PI) / 180) *
              Math.sin(dLon / 2) *
              Math.sin(dLon / 2);
          return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // Enhanced progress updates with contextual information
        function updateSearchProgress(processed, total, nearest) {
          const progress = Math.min(processed, total);
          const percentage = Math.round((progress / total) * 100);

          let message = `🔍 Searching locations... ${progress}/${total} (${percentage}%)`;

          if (nearest) {
            message += `\n🎯 Current best: ${
              nearest.display
            } (${nearest.dist.toFixed(1)}km)`;
          }

          if (loadingDiv.querySelector("p")) {
            loadingDiv.querySelector("p").innerHTML = message.replace(
              "\n",
              "<br>"
            );
          }
        }

        // Smart location selection with user feedback
        async function selectDetectedLocation(searchResult) {
          const { location, nearbyLocations } = searchResult;

          selectedLocation = location.name;
          locationSelect.value = location.name;

          // Enhanced option text with detailed info
          const option = Array.from(locationSelect.options).find(
            (opt) => opt.value === location.name
          );

          if (option) {
            const confidence = Math.round(searchResult.confidence * 100);
            const distanceText =
              location.dist < 1
                ? `${Math.round(location.dist * 1000)}m`
                : `${location.dist.toFixed(1)}km`;

            option.textContent = `🎯 ${location.display} (${distanceText} away, ${confidence}% confidence)`;
          }

          // Load prayer data
          await loadPrayerData();

          // Show nearby locations if available
          if (nearbyLocations && nearbyLocations.length > 1) {
            this.showNearbyLocations(nearbyLocations, location);
          }

          // Show success notification
          this.showAutoDetectionSuccess(location, searchResult.confidence);
        }

        // 📍 NEARBY LOCATIONS DISPLAY
        function showNearbyLocations(nearbyLocations, selectedLocation) {
          // Create nearby locations panel
          const nearbyPanel = document.createElement("div");
          nearbyPanel.id = "nearby-locations-panel";
          nearbyPanel.className =
            "glass-morphism rounded-3xl shadow-2xl p-6 sm:p-8 mt-6 fade-in";

          const nearbyLocationsHtml = `
            <div class="text-center mb-6">
              <div class="inline-flex items-center justify-center w-12 h-12 glass-morphism rounded-xl mb-4">
                <i class="fas fa-map-marker-alt text-xl text-white"></i>
              </div>
              <h3 class="text-xl sm:text-2xl font-bold text-white mb-2">📍 Nearby Prayer Locations</h3>
              <p class="text-white text-opacity-80 text-sm sm:text-base">Found ${
                nearbyLocations.length
              } locations within 50km of your position</p>
            </div>
            
            <div class="space-y-3 max-h-96 overflow-y-auto custom-scrollbar">
              ${nearbyLocations
                .map((loc, index) => {
                  const isSelected = loc.name === selectedLocation.name;
                  const distanceText =
                    loc.dist < 1
                      ? `${Math.round(loc.dist * 1000)}m`
                      : `${loc.dist.toFixed(1)}km`;

                  const cardClass = isSelected
                    ? "bg-gradient-to-r from-[#1a5f4a] to-[#2d8659] text-white border-[#2d8659]"
                    : "bg-white bg-opacity-95 hover:bg-opacity-100 text-gray-800 border-gray-200 hover:border-[#2d8659]";

                  const iconClass = isSelected
                    ? "text-white"
                    : "text-[#1a5f4a]";
                  const badgeClass = isSelected
                    ? "bg-white bg-opacity-20 text-white"
                    : "bg-[#e6f2ed] text-[#1a5f4a]"; // subtle badge for unselected

                  return `
                    <div class="nearby-location-card ${cardClass} border-2 rounded-xl p-4 transition-all duration-300 cursor-pointer transform hover:scale-[1.02] hover:shadow-lg"
                        data-location="${loc.name}" 
                        data-display="${loc.display}">
                      <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3 flex-1 min-w-0">
                          <div class="flex items-center justify-center w-8 h-8 rounded-lg ${
                            isSelected
                              ? "bg-white bg-opacity-20"
                              : "bg-[#e6f2ed]"
                          }">
                            <i class="fas fa-${
                              isSelected ? "check-circle" : "mosque"
                            } ${iconClass} text-sm"></i>
                          </div>
                          <div class="flex-1 min-w-0">
                            <p class="font-semibold text-sm sm:text-base truncate">${
                              loc.display
                            }</p>
                            <div class="flex items-center gap-2 mt-1">
                              <span class="text-xs ${
                                isSelected
                                  ? "text-white text-opacity-80"
                                  : "text-gray-600"
                              }">
                                ${distanceText} away
                              </span>
                              ${
                                isSelected
                                  ? '<span class="text-xs bg-white bg-opacity-20 px-2 py-1 rounded-full">Current Selection</span>'
                                  : ""
                              }
                            </div>
                          </div>
                        </div>
                        <div class="flex items-center gap-2">
                          <span class="text-xs ${badgeClass} px-2 py-1 rounded-full font-medium">
                            #${index + 1}
                          </span>
                          ${
                            !isSelected
                              ? '<i class="fas fa-chevron-right text-gray-400 text-xs"></i>'
                              : ""
                          }
                        </div>
                      </div>
                    </div>
                  `;
                })
                .join("")}
            </div>
            
            <div class="mt-6 p-4 bg-white bg-opacity-10 rounded-xl">
              <div class="flex items-center gap-2 text-white text-opacity-80 text-sm">
                <i class="fas fa-info-circle"></i>
                <span>Click on any location above to switch to it and view its prayer times</span>
              </div>
            </div>
          `;

          nearbyPanel.innerHTML = nearbyLocationsHtml;

          // Remove existing panel if present
          const existingPanel = document.getElementById(
            "nearby-locations-panel"
          );
          if (existingPanel) {
            existingPanel.remove();
          }

          // Insert after prayer data
          const prayerDataDiv = document.getElementById("prayer-data");
          prayerDataDiv.parentNode.insertBefore(
            nearbyPanel,
            prayerDataDiv.nextSibling
          );

          // Add click handlers for location switching
          nearbyPanel
            .querySelectorAll(".nearby-location-card")
            .forEach((card) => {
              card.addEventListener("click", async (e) => {
                const locationName = e.currentTarget.dataset.location;
                const locationDisplay = e.currentTarget.dataset.display;

                if (locationName !== selectedLocation.name) {
                  // Update selection
                  selectedLocation = locationName;
                  locationSelect.value = locationName;

                  // Update option text
                  const option = Array.from(locationSelect.options).find(
                    (opt) => opt.value === locationName
                  );
                  if (option) {
                    const clickedLocation = nearbyLocations.find(
                      (loc) => loc.name === locationName
                    );
                    const distanceText =
                      clickedLocation.dist < 1
                        ? `${Math.round(clickedLocation.dist * 1000)}m`
                        : `${clickedLocation.dist.toFixed(1)}km`;
                    option.textContent = `🎯 ${locationDisplay} (${distanceText} away)`;
                  }

                  // Show loading and reload prayer data
                  showLoading("prayer");
                  await loadPrayerData();
                  hideLoading();

                  // Update the nearby locations panel to reflect new selection
                  this.showNearbyLocations(nearbyLocations, {
                    name: locationName,
                    display: locationDisplay,
                  });

                  document.getElementById("locationName").textContent =
                    locationDisplay;

                  // Success feedback
                  console.log(`✅ Switched to: ${locationDisplay}`);
                }
              });
            });
        }

        // Hide nearby locations panel
        function hideNearbyLocations() {
          const existingPanel = document.getElementById(
            "nearby-locations-panel"
          );
          if (existingPanel) {
            existingPanel.style.opacity = "0";
            existingPanel.style.transform = "translateY(-20px)";
            setTimeout(() => {
              existingPanel.remove();
            }, 300);
          }
        }

        // Enhanced error handling with actionable suggestions
        async function handleAutoDetectionError(error) {
          let errorMessage;
          let suggestions = [];

          if (error.name === "GeolocationPositionError") {
            switch (error.code) {
              case 1:
                errorMessage = "Location access denied";
                suggestions = [
                  "Click the location icon in your browser's address bar",
                  "Allow location access and try again",
                ];
                break;
              case 2:
                errorMessage = "Location unavailable";
                suggestions = [
                  "Check your GPS/location services",
                  "Try moving to an area with better signal",
                ];
                break;
              case 3:
                errorMessage = "Location request timed out";
                suggestions = [
                  "Check your internet connection",
                  "Try again in a moment",
                ];
                break;
              default:
                errorMessage = "Location error occurred";
                suggestions = ["Please select your location manually"];
            }
          } else {
            errorMessage = error.message || "Could not auto-detect location";
            suggestions = ["Please select your location from the dropdown"];
          }

          const fullMessage = `${errorMessage}. ${suggestions.join(". ")}.`;
          showError(fullMessage);
          locationSelect.value = "";
        }

        // Success notification system
        function showAutoDetectionSuccess(location, confidence) {
          // Flash success message
          const originalTitle = document.title;
          document.title = `📍 Found: ${location.display}`;

          setTimeout(() => {
            document.title = originalTitle;
          }, 3000);

          // Console success log
          console.log(`✅ Auto-detection successful:`);
          console.log(`   📍 Location: ${location.display}`);
          console.log(`   📏 Distance: ${location.dist.toFixed(1)}km`);
          console.log(`   🎯 Confidence: ${(confidence * 100).toFixed(1)}%`);
        }

        // Spatial indexing for ultra-fast lookups (future enhancement)
        function getSpatialIndex() {
          // This would be populated from a pre-computed spatial index
          // For now, return empty object
          return {};
        }

        async function loadLocations() {
          const timingId = performanceMonitor.startTiming("loadLocations");

          try {
            showLoading("locations");
            const res = await fetch("/v1/timesheets/index.json");
            if (!res.ok) throw new Error("index.json not found");
            locations = await res.json();

            locations.sort();
            locations = locations.map((loc) => loc.replace(/_/g, " "));

            locationSelect.innerHTML = "";
            const defaultOption = document.createElement("option");
            defaultOption.textContent = "🕌 Select Your Location";
            defaultOption.value = "";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            locationSelect.appendChild(defaultOption);

            // Add auto-detect option with enhanced styling
            const autoDetectOption = document.createElement("option");
            autoDetectOption.textContent =
              "🎯 Auto-detect My Location (Recommended)";
            autoDetectOption.value = "auto-detect";
            locationSelect.appendChild(autoDetectOption);

            // Add separator
            const separatorOption = document.createElement("option");
            separatorOption.textContent = "━━━━━━━━━━━━━━━━━━━━━━━━━";
            separatorOption.disabled = true;
            locationSelect.appendChild(separatorOption);

            locations.forEach((loc) => {
              const option = document.createElement("option");
              option.textContent = `📍 ${loc}`;
              option.value = loc.replace(/ /g, "_");
              locationSelect.appendChild(option);
            });

            selectedLocation = defaultOption.value;
            hideLoading();
            setLocationFromQuery();
          } catch (err) {
            console.error("⚠️ Could not load locations:", err);
            hideLoading();
            showError(
              "Could not load locations. Please ensure the server is running and data is available."
            );
          }
        }

        periods.forEach((period, index) => {
          const btn = document.createElement("button");
          btn.className = `period-btn px-4 py-3 sm:px-6 sm:py-4 rounded-2xl font-semibold flex-1 flex items-center justify-center gap-2 text-white text-sm sm:text-base transition-all duration-300`;
          btn.dataset.value = period.value;

          const icons = {
            today: "fas fa-sun",
            month: "fas fa-calendar-week",
            year: "fas fa-calendar",
          };

          btn.innerHTML = `
          <i class="${icons[period.value]} text-sm"></i>
          <span>${period.label}</span>
        `;

          btn.addEventListener("click", () => {
            selectedPeriod = period.value;
            document
              .querySelectorAll("#period-buttons button")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
            loadPrayerData();
          });
          periodButtonsDiv.appendChild(btn);

          if (index === 0) {
            btn.classList.add("active");
          }
        });

        locationSelect.addEventListener("change", async (e) => {
          if (e.target.value === "auto-detect") {
            await autoDetectLocation();
          } else {
            selectedLocation = e.target.value;
            hideNearbyLocations(); // Hide nearby locations when manually selecting
            loadPrayerData();
          }
        });

        async function loadPrayerData() {
          if (!selectedLocation) return;
          selectedLocation = selectedLocation.replace(/ /g, "_");
          showLoading();
          hideError();
          try {
            const res = await fetch(
              `/v1/timesheets/${selectedLocation}/${selectedPeriod}.json`
            );
            let data;
            if (res.ok) {
              data = await res.json();
            } else {
              throw new Error("File not found, using demo data");
            }
            renderPrayerData({
              location: selectedLocation,
              period: selectedPeriod,
              data,
            });
          } catch (err) {
            console.error("⚠️ Could not load prayer data:", err);
            showError(
              "Could not load prayer data for the selected location and period."
            );
            prayerDataDiv.classList.add("hidden");
          }
          hideLoading();
        }

        function renderPrayerData({ location, period, data }) {
          prayerDataDiv.classList.remove("hidden");
          location = location.replace(/_/g, " ");

          let prayers = [];

          if (period === "today" && !Array.isArray(data)) {
            const { date, subh, sunrise, duhr, asar, maghrib, isha } = data;
            prayers = [
              { name: "Fajr", time: subh, icon: "fas fa-moon" },
              { name: "Sunrise", time: sunrise, icon: "fas fa-sun" },
              { name: "Dhuhr", time: duhr, icon: "fas fa-sun" },
              { name: "Asr", time: asar, icon: "fas fa-sun" },
              { name: "Maghrib", time: maghrib, icon: "fas fa-sun" },
              { name: "Isha", time: isha, icon: "fas fa-moon" },
            ];

            // Find next prayer
            let nextPrayer = getNextPrayer(prayers);
            const gregDate = formatDate(date);

            let html = `
            <div class="glass-morphism rounded-3xl shadow-2xl p-6 sm:p-8 lg:p-10">
              <!-- Header -->
              <div class="text-center mb-8 sm:mb-12">
                <div class="inline-flex items-center justify-center w-16 h-16 glass-morphism rounded-2xl mb-6">
                  <i class="fas fa-calendar-day text-2xl text-white"></i>
                </div>
                <h2 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-white mb-3">${gregDate}</h2>
                <div class="flex items-center justify-center gap-2 text-white">
                  <i class="fas fa-map-marker-alt text-sm"></i>
                  <p id="locationName" class="text-sm sm:text-base font-medium">${location}</p>
                </div>
                <div class="mt-4 inline-flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-green-50 to-yellow-50 rounded-full">
                  <div class="w-2 h-2 bg-yellow-500 rounded-full pulse-ring"></div>
                  <span class="text-sm font-medium text-white-700">Next: ${
                    nextPrayer.name
                  } at ${formatTime(nextPrayer.time)}</span>
                </div>
              </div>
              
              <!-- Prayer Times Grid -->
              <div class="prayer-time-grid">
          `;

            prayers.forEach((p) => {
              const isNext = p.name === nextPrayer.name;
              const cardClass = isNext
                ? "prayer-card active prayer-glow"
                : "prayer-card";

              html += `
              <div class="${cardClass} rounded-2xl p-4 sm:p-6 text-center">
                <div class="flex items-center justify-center w-12 h-12 mx-auto mb-4 ${
                  isNext
                    ? "bg-white bg-opacity-25"
                    : "bg-gradient-to-br from-green-50 to-yellow-50"
                } rounded-xl">
                  <i class="${p.icon} text-lg ${
                isNext ? "text-white" : "text-gray-700"
              }"></i>
                </div>
                <p class="text-xs sm:text-sm uppercase font-bold ${
                  isNext ? "text-white text-opacity-90" : "text-gray-600"
                } mb-2 tracking-wider">${p.name}</p>
                <p class="text-lg sm:text-xl lg:text-2xl font-bold ${
                  isNext ? "text-white" : "time-highlight"
                }">${formatTime(p.time)}</p>
              </div>
            `;
            });

            html += `</div></div>`;
            prayerDataDiv.innerHTML = html;
          } else if (Array.isArray(data)) {
            let days = data.map((row) => ({
              date: row.date,
              times: {
                Fajr: { time: formatTime(row.subh), icon: "fas fa-moon" },
                Sunrise: {
                  time: formatTime(row.sunrise || row.sun_rise),
                  icon: "fas fa-sun",
                },
                Dhuhr: { time: formatTime(row.duhr), icon: "fas fa-sun" },
                Asr: { time: formatTime(row.asar), icon: "fas fa-cloud-sun" },
                Maghrib: {
                  time: formatTime(row.maghrib),
                  icon: "fas fa-sunset",
                },
                Isha: { time: formatTime(row.isha), icon: "fas fa-moon" },
              },
            }));

            let html = `
            <div class="text-center mb-8 sm:mb-12">
              <div class="inline-flex items-center justify-center w-16 h-16 glass-morphism rounded-2xl mb-6">
                <i class="fas fa-${
                  period === "month" ? "calendar-week" : "calendar"
                } text-2xl text-white"></i>
              </div>
              <h2 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-white mb-3">${location}</h2>
              <p class="text-lg sm:text-xl text-white text-opacity-80 capitalize">${
                period === "month" ? "This Month" : "This Year"
              }</p>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
          `;

            days.forEach((day) => {
              const today = new Date();
              const dayDate = new Date(day.date.split("-").reverse().join("-"));
              const isToday = dayDate.toDateString() === today.toDateString();

              html += `
              <div class="glass-morphism rounded-2xl p-5 sm:p-6 ${
                isToday ? "ring-2 ring-yellow-400 ring-opacity-60" : ""
              }">
                <div class="text-center mb-5">
                  <h3 class="text-base sm:text-lg font-bold mb-2 text-white">
                    ${formatDateShort(day.date)}
                  </h3>
                </div>
                <div class="space-y-3">
                  ${Object.entries(day.times)
                    .map(
                      ([name, prayer]) => `
                      <div class="flex justify-between items-center p-2 rounded-lg bg-white bg-opacity-100">
                        <div class="flex items-center gap-2">
                          <i class="${prayer.icon} text-xs text-gray-700"></i>
                          <span class="font-medium text-gray-800 text-sm">${name}</span>
                        </div>
                        <span class="font-bold text-gray-900 text-sm">${prayer.time}</span>
                      </div>
                    `
                    )
                    .join("")}
                </div>
              </div>
            `;
            });
            html += `</div>`;
            prayerDataDiv.innerHTML = html;
          }
        }

        // 🎨 ENHANCED UI & LOADING OPTIMIZATIONS

        // Smart loading states with context
        function showLoading(context = "general") {
          const loadingMessages = {
            general: "Loading prayer data...",
            locations: "Loading available locations...",
            autodetect: "Finding your location...",
            geocoding: "Processing location data...",
            prayer: "Fetching prayer times...",
          };

          const loadingIcons = {
            general: "fas fa-spinner",
            locations: "fas fa-map",
            autodetect: "fas fa-location-arrow",
            geocoding: "fas fa-globe",
            prayer: "fas fa-mosque",
          };

          loadingDiv.classList.remove("hidden");

          const message = loadingDiv.querySelector("p");
          if (message) {
            message.textContent =
              loadingMessages[context] || loadingMessages.general;
          }

          // Add contextual icon if available
          const icon = loadingDiv.querySelector(".loading-icon");
          if (icon) {
            icon.className = `loading-icon ${
              loadingIcons[context] || loadingIcons.general
            } text-yellow-400`;
          }
        }

        function hideLoading() {
          loadingDiv.classList.add("hidden");
        }

        function hideError() {
          errorDiv.classList.add("hidden");
        }

        function showError(msg) {
          errorDiv.classList.remove("hidden");
          errorDiv.querySelector("p").textContent = msg;
        }

        // Enhanced progress tracking
        class ProgressTracker {
          constructor() {
            this.currentOperation = null;
            this.startTime = null;
            this.steps = [];
          }

          start(operation, totalSteps = 1) {
            this.currentOperation = operation;
            this.startTime = performance.now();
            this.steps = [];
            this.totalSteps = totalSteps;
            this.currentStep = 0;
          }

          step(description, data = {}) {
            this.currentStep++;
            const elapsed = performance.now() - this.startTime;

            const step = {
              step: this.currentStep,
              description,
              elapsed: Math.round(elapsed),
              data,
              timestamp: new Date().toISOString(),
            };

            this.steps.push(step);

            // Update UI with progress
            this.updateUI();

            console.log(
              `📊 Step ${this.currentStep}/${
                this.totalSteps
              }: ${description} (${elapsed.toFixed(0)}ms)`
            );
          }

          complete(result = {}) {
            const totalTime = performance.now() - this.startTime;
            console.log(
              `✅ ${this.currentOperation} completed in ${totalTime.toFixed(
                0
              )}ms`
            );

            this.currentOperation = null;
            return {
              operation: this.currentOperation,
              totalTime,
              steps: this.steps,
              result,
            };
          }

          updateUI() {
            const progress = (this.currentStep / this.totalSteps) * 100;
            const currentStep = this.steps[this.steps.length - 1];

            if (loadingDiv.querySelector("p") && this.currentOperation) {
              const message = `${currentStep.description}... (${this.currentStep}/${this.totalSteps})`;
              loadingDiv.querySelector("p").innerHTML = message;
            }
          }
        }

        const progressTracker = new ProgressTracker();

        // Smart error handling with recovery suggestions
        function showSmartError(error, context = "general") {
          const errorStrategies = {
            geolocation: {
              title: "Location Access Issue",
              suggestions: [
                "Allow location access in your browser",
                "Check if location services are enabled",
                "Try selecting a location manually",
              ],
              icon: "fas fa-location-arrow",
            },
            network: {
              title: "Connection Issue",
              suggestions: [
                "Check your internet connection",
                "Try refreshing the page",
                "Wait a moment and try again",
              ],
              icon: "fas fa-wifi",
            },
            geocoding: {
              title: "Location Processing Error",
              suggestions: [
                "The location might not be in our database",
                "Try selecting a nearby location manually",
                "Contact support if this persists",
              ],
              icon: "fas fa-map-marker-alt",
            },
            data: {
              title: "Prayer Data Unavailable",
              suggestions: [
                "Prayer times may not be available for this location",
                "Try selecting a different location",
                "Check back later",
              ],
              icon: "fas fa-mosque",
            },
          };

          const strategy = errorStrategies[context] || {
            title: "An Error Occurred",
            suggestions: [
              "Please try again",
              "Contact support if the issue persists",
            ],
            icon: "fas fa-exclamation-triangle",
          };

          const errorHtml = `
            <div class="flex items-start gap-4">
              <div class="flex items-center justify-center w-12 h-12 bg-red-100 rounded-full flex-shrink-0">
                <i class="${strategy.icon} text-red-600 text-xl"></i>
              </div>
              <div class="flex-1">
                <h3 class="text-red-800 font-bold text-lg mb-2">${
                  strategy.title
                }</h3>
                <p class="text-red-700 mb-3">${error.message || error}</p>
                <div class="space-y-1">
                  <p class="text-red-600 font-medium text-sm">Try these solutions:</p>
                  <ul class="text-red-600 text-sm space-y-1">
                    ${strategy.suggestions
                      .map(
                        (suggestion) =>
                          `<li class="flex items-start gap-2">
                        <i class="fas fa-chevron-right text-xs mt-1 flex-shrink-0"></i>
                        <span>${suggestion}</span>
                      </li>`
                      )
                      .join("")}
                  </ul>
                </div>
              </div>
            </div>
          `;

          errorDiv.innerHTML = errorHtml;
          errorDiv.classList.remove("hidden");
        }

        function formatTime(time) {
          if (!time) return "";

          // Today's date + given time (safe parsing of AM/PM)
          const today = new Date();
          const dateString = `${today.toDateString()} ${time}`;

          const date = new Date(dateString);

          // Ensure valid Date
          if (isNaN(date.getTime())) {
            return time; // fallback to raw if parsing fails
          }

          return date.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          });
        }

        function getNextPrayer(prayers) {
          const now = new Date();

          // Convert prayer times into Date objects for today
          const today = now.toDateString();
          const times = prayers.map((p) => {
            const date = new Date(`${today} ${p.time}`);
            return { ...p, date };
          });

          // Find the first prayer after now
          const next = times.find((p) => p.date > now);

          return next || times[0]; // default to last prayer if past Isha
        }

        function formatDate(dateStr) {
          const [day, month, year] = dateStr.split("-");
          const date = new Date(year, month - 1, day);
          return date.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });
        }

        function formatDateShort(dateStr) {
          const [day, month, year] = dateStr.split("-");
          const date = new Date(year, month - 1, day);
          return date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            weekday: "short",
          });
        }

        // Add smooth transitions when data loads
        function showContent(element) {
          element.style.opacity = "0";
          element.classList.remove("hidden");
          setTimeout(() => {
            element.style.transition = "opacity 0.5s ease-in-out";
            element.style.opacity = "1";
          }, 10);
        }

        function showLoading() {
          loadingDiv.classList.remove("hidden");
        }
        function hideLoading() {
          loadingDiv.classList.add("hidden");
        }
        function hideError() {
          errorDiv.classList.add("hidden");
        }
        function showError(msg) {
          errorDiv.classList.remove("hidden");
          errorDiv.querySelector("p").textContent = msg;
        }
        function getQueryParam(param) {
          const urlParams = new URLSearchParams(window.location.search);
          return urlParams.get(param);
        }

        function setLocationFromQuery() {
          let queryLocation = getQueryParam("q");

          if (queryLocation) {
            const locationSelect = document.getElementById("location");

            const selectedOption = Array.from(locationSelect.options).find(
              (opt) => {
                return (
                  opt.value.replace(/ /g, "_") ===
                  queryLocation.replace(/ /g, "_")
                );
              }
            );

            if (selectedOption) {
              locationSelect.value = selectedOption.value;
              selectedLocation = selectedOption.value;
              loadPrayerData();
            }
          }
        }

        // Initialize the dashboard
        document.addEventListener("DOMContentLoaded", () => {
          // Advanced cache is auto-initialized in constructor

          loadLocations();

          // Log enhanced initialization info
          console.log(
            "🚀 Prayer Times Dashboard initialized with world-class optimizations"
          );
          console.log(
            "💡 Advanced cache utilities available via window.azanCache"
          );
          console.log(
            "   • azanCache.stats() - Show detailed cache statistics"
          );
          console.log("   • azanCache.clear() - Clear all cached locations");
          console.log("   • azanCache.size() - Get cache size");
          console.log("   • azanCache.health() - Check cache health");
          console.log(
            "   • azanCache.inspect(key) - Inspect specific cache entry"
          );
          console.log(
            "   • azanCache.performance() - View performance metrics"
          );

          // Add keyboard navigation
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              hideError();
            }
          });

          // Parallax effect for floating elements
          let scrollY = 0;

          function updateParallax() {
            scrollY = window.scrollY;
            const floatingElements =
              document.querySelectorAll(".floating-element");

            floatingElements.forEach((element, index) => {
              const speed = ((index % 3) + 1) * 0.5; // Different speeds for different elements
              const yPos = -(scrollY * speed);
              element.style.transform = `translateY(${yPos}px)`;
            });

            requestAnimationFrame(updateParallax);
          }

          // Start parallax effect
          updateParallax();

          // Smooth entrance animations for cards
          const observerOptions = {
            threshold: 0.1,
            rootMargin: "0px 0px -50px 0px",
          };

          const cardObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry, index) => {
              if (entry.isIntersecting) {
                setTimeout(() => {
                  entry.target.style.opacity = "1";
                  entry.target.style.transform = "translateY(0)";
                }, index * 100);
              }
            });
          }, observerOptions);

          // Observe all glass cards
          document.querySelectorAll(".glass-card").forEach((card) => {
            card.style.opacity = "0";
            card.style.transform = "translateY(30px)";
            card.style.transition = "opacity 0.6s ease, transform 0.6s ease";
            cardObserver.observe(card);
          });
        });
      </script>
    </div>
    <!-- Close dark horizon glow container -->
  </body>
</html>
