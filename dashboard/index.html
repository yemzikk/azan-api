<!DOCTYPE html>
<html lang="en">
  <head>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-LC24F79QZ5"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-LC24F79QZ5");
    </script>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
    />
    <title>Prayer Times Kerala</title>
    <!-- Primary Meta Tags -->
    <title>
      Kerala Prayer Times - Accurate Islamic Prayer Schedules for Kerala
    </title>
    <meta
      name="description"
      content="Track Islamic prayer times for Kerala with a beautiful dashboard. Select your location and time period to get precise daily, monthly, or yearly schedules for every salah."
    />
    <meta
      name="keywords"
      content="prayer times dashboard, Kerala prayer times, Islamic prayer schedule, daily salah times, azan timetable, masjid prayer API, free prayer times, Muslim dashboard, Kerala salah times, prayer times app, fajr maghrib isha Kerala, serve the ummah, mosque schedule, Islamic app tools"
    />
    <meta name="author" content="azantimes.in" />
    <meta name="robots" content="index, follow" />
    <link rel="canonical" href="https://azantimes.in/" />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://azantimes.in/" />
    <meta
      property="og:title"
      content="Kerala Prayer Times - Islamic Prayer Schedules for Kerala"
    />
    <meta
      property="og:description"
      content="A clean dashboard to view and track Islamic prayer times by location and date in Kerala. Built for precision, care, and the Ummah."
    />
    <meta property="og:image" content="https://azantimes.in/prayer-times.png" />

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:url" content="https://azantimes.in/" />
    <meta
      name="twitter:title"
      content="Kerala Prayer Times - Islamic Prayer Schedules for Kerala"
    />
    <meta
      name="twitter:description"
      content="Browse and track Kerala's daily, monthly, and yearly Islamic prayer timings in one place, beautifully presented."
    />
    <meta
      name="twitter:image"
      content="https://azantimes.in/prayer-times.png"
    />

    <!-- App Icons & Manifest -->
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="/favicon/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="/favicon/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="/favicon/favicon-16x16.png"
    />
    <link rel="manifest" href="/favicon/site.webmanifest" />

    <!-- PWA Meta Tags -->
    <meta name="application-name" content="Prayer Times Kerala" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta
      name="apple-mobile-web-app-status-bar-style"
      content="black-translucent"
    />
    <meta name="apple-mobile-web-app-title" content="Prayer Times Kerala" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="msapplication-TileColor" content="#1a5f4a" />
    <meta name="msapplication-config" content="/favicon/browserconfig.xml" />
    <meta name="theme-color" content="#1a5f4a" />

    <!-- Additional PWA Meta Tags for proper app recognition -->
    <meta name="apple-touch-fullscreen" content="yes" />
    <meta name="format-detection" content="telephone=no" />
    <meta name="msapplication-navbutton-color" content="#1a5f4a" />
    <meta name="msapplication-starturl" content="/" />
    <meta name="color-scheme" content="light" />

    <!-- Structured Data (JSON-LD) -->
    <script type="application/ld+json">
      {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Kerala Prayer Times",
        "url": "https://azantimes.in/",
        "description": "Dashboard to track and browse Islamic prayer times for Kerala locations by date with a beautiful interface. Perfect for the Ummah and app developers.",
        "applicationCategory": "Religion & Spirituality, Tools",
        "operatingSystem": "All",
        "image": "https://azantimes.in/prayer-times.png",
        "author": {
          "@type": "Organization",
          "name": "azantimes.in"
        },
        "offers": {
          "@type": "Offer",
          "price": "0",
          "priceCurrency": "USD"
        }
      }
    </script>

    <link rel="stylesheet" href="../css/styles.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <style>
      * {
        font-family: "Inter", sans-serif;
      }

      body {
        background: linear-gradient(
          135deg,
          #0f4c3a 0%,
          #1a5f4a 50%,
          #2d8659 100%
        );
        min-height: 100vh;
        position: relative;
        overflow-x: hidden;
      }

      body::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: radial-gradient(
            circle at 20% 20%,
            rgba(255, 255, 255, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 80% 80%,
            rgba(255, 255, 255, 0.08) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 40% 40%,
            rgba(255, 255, 255, 0.04) 0%,
            transparent 50%
          ),
          radial-gradient(
            circle at 60% 20%,
            rgba(255, 255, 255, 0.06) 0%,
            transparent 40%
          ),
          radial-gradient(
            circle at 10% 70%,
            rgba(255, 255, 255, 0.06) 0%,
            transparent 40%
          );
        pointer-events: none;
        animation: backgroundShift 20s ease-in-out infinite;
      }

      @keyframes backgroundShift {
        0%,
        100% {
          opacity: 0.8;
        }
        50% {
          opacity: 1;
        }
      }

      .glass-morphism {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(212, 175, 55, 0.2);
        box-shadow: 0 8px 32px 0 rgba(15, 76, 58, 0.2);
      }

      .glass-card {
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(25px);
        border: 1px solid rgba(212, 175, 55, 0.25);
        box-shadow: 0 20px 40px rgba(15, 76, 58, 0.15);
        transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .glass-card:hover {
        transform: translateY(-8px) scale(1.02);
        box-shadow: 0 30px 60px rgba(15, 76, 58, 0.2);
        background: rgba(255, 255, 255, 1);
        border-color: rgba(212, 175, 55, 0.4);
      }

      .prayer-card {
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 0.92),
          rgba(255, 255, 255, 0.75)
        );
        backdrop-filter: blur(20px);
        border: 1px solid rgba(212, 175, 55, 0.3);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
      }

      .prayer-card::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        height: 3px;
        background: linear-gradient(90deg, #d4af37, #f4d03f);
        transform: scaleX(0);
        transition: transform 0.3s ease;
      }

      .prayer-card:hover::before {
        transform: scaleX(1);
      }

      .prayer-card:hover {
        transform: translateY(-4px);
        box-shadow: 0 25px 50px rgba(15, 76, 58, 0.15);
        background: linear-gradient(
          145deg,
          rgba(255, 255, 255, 1),
          rgba(255, 255, 255, 0.95)
        );
        border-color: rgba(212, 175, 55, 0.5);
      }

      .prayer-card.active {
        background: linear-gradient(145deg, #1a5f4a, #2d8659);
        color: white;
        transform: translateY(-2px) scale(1.05);
        box-shadow: 0 20px 40px rgba(26, 95, 74, 0.4);
        border-color: rgba(212, 175, 55, 0.6);
      }

      .prayer-card.active::before {
        background: rgba(212, 175, 55, 0.8);
        transform: scaleX(1);
      }

      .period-btn {
        background: rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(212, 175, 55, 0.25);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        overflow: hidden;
        color: rgba(255, 255, 255, 0.9);
        font-weight: 600;
      }

      .period-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          90deg,
          transparent,
          rgba(212, 175, 55, 0.2),
          transparent
        );
        transition: left 0.5s;
      }

      .period-btn:hover::before {
        left: 100%;
      }

      .period-btn:hover {
        transform: translateY(-2px);
        background: rgba(212, 175, 55, 0.2);
        box-shadow: 0 10px 25px rgba(15, 76, 58, 0.2);
        color: white;
        border-color: rgba(212, 175, 55, 0.5);
      }

      .period-btn.active {
        background: rgba(212, 175, 55, 0.9);
        color: #0f4c3a;
        transform: translateY(-2px);
        box-shadow: 0 10px 25px rgba(212, 175, 55, 0.3);
        border-color: rgba(212, 175, 55, 0.8);
        font-weight: 700;
      }

      .floating-element {
        animation: float 8s ease-in-out infinite;
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0px) translateX(0px) rotate(0deg);
          opacity: 0.6;
        }
        25% {
          transform: translateY(-15px) translateX(5px) rotate(90deg);
          opacity: 0.8;
        }
        50% {
          transform: translateY(-25px) translateX(-5px) rotate(180deg);
          opacity: 0.4;
        }
        75% {
          transform: translateY(-10px) translateX(8px) rotate(270deg);
          opacity: 0.7;
        }
      }

      .fade-in {
        animation: fadeIn 0.8s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(30px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .slide-in {
        animation: slideIn 0.6s ease-out;
      }

      @keyframes slideIn {
        from {
          opacity: 0;
          transform: translateX(-30px);
        }
        to {
          opacity: 1;
          transform: translateX(0);
        }
      }

      .prayer-glow {
        animation: prayerPulse 4s ease-in-out infinite;
      }

      @keyframes prayerPulse {
        0%,
        100% {
          box-shadow: 0 0 20px rgba(212, 175, 55, 0.2);
        }
        50% {
          box-shadow: 0 0 30px rgba(212, 175, 55, 0.4),
            0 0 40px rgba(26, 95, 74, 0.2);
        }
      }

      .prayer-time-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
        gap: 1rem;
      }

      @media (min-width: 640px) {
        .prayer-time-grid {
          grid-template-columns: repeat(3, 1fr);
          gap: 1.5rem;
        }
      }

      @media (min-width: 1024px) {
        .prayer-time-grid {
          grid-template-columns: repeat(6, 1fr);
          gap: 1.5rem;
        }
      }

      .select-wrapper {
        position: relative;
      }

      .select-wrapper::after {
        content: "\f107";
        font-family: "Font Awesome 6 Free";
        font-weight: 900;
        position: absolute;
        right: 15px;
        top: 50%;
        transform: translateY(-50%);
        pointer-events: none;
        color: #1a5f4a;
        transition: transform 0.3s ease;
      }

      .select-wrapper:hover::after {
        transform: translateY(-50%) scale(1.1);
      }

      select {
        appearance: none;
        background: rgba(255, 255, 255, 0.92);
        backdrop-filter: blur(15px);
        border: 1px solid rgba(212, 175, 55, 0.3);
        transition: all 0.3s ease;
      }

      select:focus {
        background: rgba(255, 255, 255, 1);
        border-color: #1a5f4a;
        box-shadow: 0 0 0 3px rgba(26, 95, 74, 0.15);
        outline: none;
      }

      /* Select option styling */
      select option[value="auto-detect"] {
        background: linear-gradient(135deg, #d4af37, #f4d03f);
        color: #0f4c3a;
        font-weight: bold;
      }

      select option:disabled {
        color: rgba(128, 128, 128, 0.6);
        font-style: italic;
      }

      .time-highlight {
        background: linear-gradient(135deg, #1a5f4a, #124a39);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        font-weight: 700;
      }

      .pulse-ring {
        animation: pulse-ring 2s infinite;
      }

      @keyframes pulse-ring {
        0% {
          transform: scale(0.33);
        }
        40%,
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0;
          transform: scale(1.2);
        }
      }

      .loading-dots {
        display: inline-block;
        position: relative;
        width: 80px;
        height: 80px;
      }

      .loading-dots div {
        position: absolute;
        top: 33px;
        width: 13px;
        height: 13px;
        border-radius: 50%;
        background: #d4af37;
        animation-timing-function: cubic-bezier(0, 1, 1, 0);
      }

      .loading-dots div:nth-child(1) {
        left: 8px;
        animation: loading1 0.6s infinite;
      }

      .loading-dots div:nth-child(2) {
        left: 8px;
        animation: loading2 0.6s infinite;
      }

      .loading-dots div:nth-child(3) {
        left: 32px;
        animation: loading2 0.6s infinite;
      }

      .loading-dots div:nth-child(4) {
        left: 56px;
        animation: loading3 0.6s infinite;
      }

      @keyframes loading1 {
        0% {
          transform: scale(0);
        }
        100% {
          transform: scale(1);
        }
      }

      @keyframes loading3 {
        0% {
          transform: scale(1);
        }
        100% {
          transform: scale(0);
        }
      }

      @keyframes loading2 {
        0% {
          transform: translate(0, 0);
        }
        100% {
          transform: translate(24px, 0);
        }
      }

      .moroccan-pattern {
        background: linear-gradient(
          135deg,
          #0f4c3a 0%,
          #1a5f4a 50%,
          #2d8659 100%
        );
        background-image: 
          /* Islamic Star Pattern */ radial-gradient(
            circle at 25px 25px,
            rgba(212, 175, 55, 0.08) 2px,
            transparent 2px
          ),
          radial-gradient(
            circle at 75px 75px,
            rgba(212, 175, 55, 0.06) 2px,
            transparent 2px
          ),
          /* Geometric Grid */
            repeating-linear-gradient(
              45deg,
              rgba(212, 175, 55, 0.02) 0px,
              rgba(212, 175, 55, 0.02) 1px,
              transparent 1px,
              transparent 12px
            ),
          repeating-linear-gradient(
            -45deg,
            rgba(212, 175, 55, 0.02) 0px,
            rgba(212, 175, 55, 0.02) 1px,
            transparent 1px,
            transparent 12px
          ),
          /* Hexagonal Pattern */
            linear-gradient(
              60deg,
              rgba(212, 175, 55, 0.01) 25%,
              transparent 25.5%,
              transparent 75%,
              rgba(212, 175, 55, 0.01) 75.5%,
              rgba(212, 175, 55, 0.01)
            ),
          linear-gradient(
            -60deg,
            rgba(212, 175, 55, 0.01) 25%,
            transparent 25.5%,
            transparent 75%,
            rgba(212, 175, 55, 0.01) 75.5%,
            rgba(212, 175, 55, 0.01)
          );
        background-size: 50px 50px, 100px 100px, 24px 24px, 24px 24px, 60px 36px,
          60px 36px;
        background-position: 0 0, 25px 25px, 0 0, 12px 12px, 0 0, 30px 18px;
      }

      /* Mobile optimizations */
      @media (max-width: 640px) {
        .prayer-time-grid {
          grid-template-columns: repeat(2, 1fr);
          gap: 1rem;
        }

        .glass-card {
          padding: 1rem;
        }

        .floating-element {
          display: none;
        }
      }

      /* Smooth scrolling */
      html {
        scroll-behavior: smooth;
      }

      /* Focus states for accessibility */
      button:focus,
      select:focus {
        outline: 2px solid rgba(212, 175, 55, 0.6);
        outline-offset: 2px;
      }

      /* Loading animation enhancement */
      .pulse-ring {
        position: relative;
      }

      .pulse-ring::before {
        content: "";
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%;
        height: 100%;
        border-radius: 50%;
        background: rgba(212, 175, 55, 0.4);
        transform: translate(-50%, -50%);
        animation: pulse-ring 2s infinite;
      }

      /* Enhanced hover effects */
      .glass-card:hover {
        background: rgba(255, 255, 255, 0.98);
        border-color: rgba(212, 175, 55, 0.5);
      }

      .prayer-card.active:hover {
        background: linear-gradient(145deg, #1a5f4a, #2d8659);
      }

      /* Nearby Locations Panel Styles */
      .custom-scrollbar {
        scrollbar-width: thin;
        scrollbar-color: rgba(212, 175, 55, 0.6) rgba(255, 255, 255, 0.1);
      }

      .custom-scrollbar::-webkit-scrollbar {
        width: 6px;
      }

      .custom-scrollbar::-webkit-scrollbar-track {
        background: rgba(255, 255, 255, 0.1);
        border-radius: 3px;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb {
        background: rgba(212, 175, 55, 0.6);
        border-radius: 3px;
      }

      .custom-scrollbar::-webkit-scrollbar-thumb:hover {
        background: rgba(212, 175, 55, 0.8);
      }

      .nearby-location-card {
        backdrop-filter: blur(10px);
        animation: slideInUp 0.3s ease-out;
      }

      .nearby-location-card:nth-child(odd) {
        animation-delay: 0.05s;
      }

      .nearby-location-card:nth-child(even) {
        animation-delay: 0.1s;
      }

      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .nearby-location-card:hover {
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
      }

      /* Auto-detection success animation */
      .detection-success {
        animation: successPulse 0.6s ease-out;
      }

      @keyframes successPulse {
        0% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
        }
        50% {
          transform: scale(1.05);
          box-shadow: 0 0 0 10px rgba(34, 197, 94, 0);
        }
        100% {
          transform: scale(1);
          box-shadow: 0 0 0 0 rgba(34, 197, 94, 0);
        }
      }

      /* PWA Install Banner */
      .pwa-banner {
        background: linear-gradient(135deg, #1a5f4a, #2d8659);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(212, 175, 55, 0.3);
        box-shadow: 0 10px 30px rgba(15, 76, 58, 0.2);
        transform: translateY(-100%);
        transition: transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      }

      .pwa-banner.show {
        transform: translateY(0);
      }

      .pwa-banner-slide-out {
        transform: translateY(-100%);
      }

      @keyframes sparkle {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.8;
          transform: scale(1.05);
        }
      }

      /* PWA Update Available */
      .update-banner {
        background: linear-gradient(135deg, #3b82f6, #2563eb);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(59, 130, 246, 0.3);
        box-shadow: 0 10px 30px rgba(59, 130, 246, 0.2);
      }
    </style>
  </head>
  <body class="min-h-screen moroccan-pattern">
    <!-- Dark Horizon Glow Background -->
    <div class="min-h-screen w-full relative">
      <div
        class="absolute inset-0 z-0"
        style="
          background: radial-gradient(
            125% 125% at 50% 90%,
            #0a2e1f 40%,
            #1a5f4a 100%
          );
        "
      ></div>

      <div
        class="relative z-20 container mx-auto px-4 sm:px-6 lg:px-8 py-6 sm:py-8 lg:py-12"
      >
        <!-- PWA Install Banner -->
        <div
          id="pwa-banner"
          class="pwa-banner fixed top-0 left-0 right-0 z-50 hidden"
        >
          <div class="flex items-center justify-between p-4 text-white">
            <div class="flex items-center gap-3">
              <i class="fas fa-download text-xl"></i>
              <div>
                <p class="font-semibold">Install Prayer Times App</p>
                <p class="text-sm opacity-90">
                  Get faster access and offline support
                </p>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button
                id="install-pwa-btn"
                class="bg-yellow-500 text-gray-900 px-4 py-2 rounded-lg font-semibold hover:bg-yellow-400 transition-colors"
              >
                Install
              </button>
              <button
                id="dismiss-pwa-btn"
                class="text-white hover:text-yellow-300 p-2"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
        </div>

        <!-- Update Available Banner -->
        <div
          id="update-banner"
          class="update-banner fixed top-0 left-0 right-0 z-50 hidden"
        >
          <div class="flex items-center justify-between p-4 text-white">
            <div class="flex items-center gap-3">
              <i class="fas fa-sync-alt text-xl"></i>
              <div>
                <p class="font-semibold">Update Available</p>
                <p class="text-sm opacity-90">
                  Refresh to get the latest features
                </p>
              </div>
            </div>
            <div class="flex items-center gap-2">
              <button
                id="update-app-btn"
                class="bg-blue-500 text-white px-4 py-2 rounded-lg font-semibold hover:bg-blue-400 transition-colors"
              >
                Update
              </button>
              <button
                id="dismiss-update-btn"
                class="text-white hover:text-blue-300 p-2"
              >
                <i class="fas fa-times"></i>
              </button>
            </div>
          </div>
        </div>

        <!-- Header -->
        <div class="text-center mb-8 sm:mb-12 fade-in">
          <div class="mb-6">
            <div
              class="inline-flex items-center justify-center w-20 h-20 sm:w-24 sm:h-24 glass-morphism rounded-full mb-6"
            >
              <i class="fas fa-mosque text-3xl sm:text-4xl text-white"></i>
            </div>
          </div>
          <h1
            class="text-4xl sm:text-5xl lg:text-6xl font-bold text-white mb-4 tracking-tight"
          >
            Prayer Times
            <span
              class="block text-2xl sm:text-3xl lg:text-4xl font-light text-white text-opacity-90 mt-2"
              >Dashboard</span
            >
          </h1>
          <p
            class="text-lg sm:text-xl text-white text-opacity-80 max-w-2xl mx-auto leading-relaxed"
          >
            Track Islamic prayer schedules with precision and beauty across
            locations and time periods
          </p>
        </div>

        <!-- Controls -->
        <div
          class="glass-morphism rounded-3xl shadow-2xl p-6 sm:p-8 mb-8 sm:mb-12 slide-in"
        >
          <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8">
            <!-- Location Selector -->
            <div class="space-y-3">
              <div class="flex items-center justify-between">
                <label
                  class="flex items-center gap-3 text-white font-semibold text-sm sm:text-base"
                >
                  <div
                    class="flex items-center justify-center w-8 h-8 bg-white bg-opacity-20 rounded-lg"
                  >
                    <i class="fas fa-map-marker-alt text-white text-sm"></i>
                  </div>
                  Select Location
                </label>
              </div>
              <div class="select-wrapper">
                <select
                  id="location"
                  class="w-full px-4 sm:px-6 py-3 sm:py-4 rounded-2xl text-gray-800 font-medium text-sm sm:text-base cursor-pointer focus:ring-4 focus:ring-white focus:ring-opacity-20"
                ></select>
              </div>
            </div>

            <!-- Period Selector -->
            <div class="space-y-3">
              <label
                class="flex items-center gap-3 text-white font-semibold text-sm sm:text-base"
              >
                <div
                  class="flex items-center justify-center w-8 h-8 bg-white bg-opacity-20 rounded-lg"
                >
                  <i class="fas fa-calendar-alt text-white text-sm"></i>
                </div>
                Select Time Period
              </label>
              <div class="flex gap-3" id="period-buttons"></div>
            </div>
          </div>
        </div>

        <!-- Loader -->
        <div
          id="loading"
          class="hidden glass-morphism rounded-3xl shadow-2xl p-8 sm:p-12"
        >
          <div class="flex flex-col items-center justify-center space-y-6">
            <div class="loading-dots">
              <div></div>
              <div></div>
              <div></div>
              <div></div>
            </div>
            <p class="text-white text-lg sm:text-xl font-medium">
              Loading prayer data...
            </p>
          </div>
        </div>

        <!-- Error -->
        <div
          id="error"
          class="hidden glass-morphism rounded-3xl p-6 sm:p-8 border border-red-200"
        >
          <div class="flex items-center gap-4">
            <div
              class="flex items-center justify-center w-12 h-12 bg-red-100 rounded-full"
            >
              <i class="fas fa-exclamation-triangle text-red-600 text-xl"></i>
            </div>
            <p
              class="text-red-600 font-semibold text-sm sm:text-base flex-1"
            ></p>
          </div>
        </div>

        <!-- Prayer Data -->
        <div id="prayer-data" class="hidden fade-in"></div>

        <!-- Footer -->
        <footer class="text-center mt-12 sm:mt-16 fade-in">
          <div
            class="glass-morphism rounded-2xl p-6 sm:p-8 border border-white border-opacity-20"
          >
            <div
              class="flex flex-col sm:flex-row items-center justify-center gap-4 sm:gap-8 text-white"
            >
              <div class="flex items-center gap-2">
                <i class="fas fa-mosque text-lg text-white"></i>
                <span class="font-semibold text-white">Prayer Times API</span>
              </div>
              <div class="flex items-center gap-2">
                <i class="fas fa-code text-sm text-white"></i>
                <span class="text-sm font-medium text-white"
                  >Built with precision & care</span
                >
              </div>
              <div class="flex items-center gap-2">
                <i class="fas fa-heart text-red-300 text-sm"></i>
                <span class="text-sm font-medium text-white"
                  >Serving the Ummah</span
                >
              </div>
            </div>
          </div>
        </footer>
      </div>

      <script>
        // 🔥 PWA FUNCTIONALITY & SERVICE WORKER REGISTRATION

        let deferredPrompt = null;
        let defaultLocation = null;

        // PWA Installation and Service Worker Setup
        class PWAManager {
          constructor() {
            this.swRegistration = null;
            this.installPrompt = null;
            this.init();
          }

          async init() {
            // Register service worker
            if ("serviceWorker" in navigator) {
              try {
                this.swRegistration = await navigator.serviceWorker.register(
                  "/sw.js",
                  {
                    updateViaCache: "none", // Always check for updates
                  }
                );

                console.log("✅ Service Worker registered successfully");

                // Listen for updates
                this.swRegistration.addEventListener("updatefound", () => {
                  console.log("🔄 New service worker available");
                  this.handleServiceWorkerUpdate();
                });

                // Check for existing service worker updates
                if (this.swRegistration.waiting) {
                  this.handleServiceWorkerUpdate();
                }

                // Listen for controller changes (when new SW takes control)
                navigator.serviceWorker.addEventListener(
                  "controllerchange",
                  () => {
                    console.log("🔄 New service worker took control");
                  }
                );

                // Check for updates periodically
                this.setupUpdateChecker();
              } catch (error) {
                console.warn("❌ Service Worker registration failed:", error);
              }
            }

            // Setup PWA install prompt
            this.setupInstallPrompt();

            // Setup date change detection for PWA auto-refresh
            this.setupDateChecker();

            // Setup auto-refresh for today's data
            this.setupAutoRefresh();

            // Load user preferences
            this.loadUserPreferences();
          }

          setupUpdateChecker() {
            // Check for updates when page becomes visible
            document.addEventListener("visibilitychange", () => {
              if (!document.hidden && this.swRegistration) {
                console.log("🔍 Checking for service worker updates");
                this.swRegistration.update();
              }
            });

            // Periodic update check (every 30 seconds when active)
            setInterval(() => {
              if (!document.hidden && this.swRegistration) {
                this.swRegistration.update();
              }
            }, 30000);
          }

          handleServiceWorkerUpdate() {
            // Check if app is running as PWA (standalone mode)
            const isStandalone =
              window.matchMedia &&
              window.matchMedia("(display-mode: standalone)").matches;
            const isIOSStandalone = window.navigator.standalone === true;
            const isPWA = isStandalone || isIOSStandalone;

            // Don't show update banner too frequently
            const lastUpdateBannerTime = localStorage.getItem(
              "last-update-banner-time"
            );
            const now = Date.now();
            const MIN_BANNER_INTERVAL = 5 * 60 * 1000; // 5 minutes

            if (isPWA) {
              // Show update banner for PWA users (but not too frequently)
              if (
                !lastUpdateBannerTime ||
                now - parseInt(lastUpdateBannerTime) > MIN_BANNER_INTERVAL
              ) {
                console.log("📱 PWA detected - showing update banner");
                localStorage.setItem("last-update-banner-time", now.toString());
                this.showUpdateBanner();
              } else {
                console.log("📱 PWA update banner shown recently, skipping");
              }
            } else {
              // Auto-update for browser users
              console.log("🌐 Browser detected - auto-updating silently");
              this.autoUpdateSilently();
            }
          }

          async autoUpdateSilently() {
            try {
              if (this.swRegistration && this.swRegistration.waiting) {
                console.log("🔄 Auto-updating service worker silently");

                // Tell the waiting service worker to skip waiting and become active
                this.swRegistration.waiting.postMessage({
                  type: "SKIP_WAITING",
                });

                // Wait for the new service worker to take control
                await new Promise((resolve) => {
                  navigator.serviceWorker.addEventListener(
                    "controllerchange",
                    resolve,
                    { once: true }
                  );
                });

                console.log("✅ Silent update completed");

                // Optionally show a brief notification
                this.showSilentUpdateNotification();
              }
            } catch (error) {
              console.warn("⚠️ Silent update failed:", error);
              // Fallback to manual update if auto-update fails
              this.showUpdateBanner();
            }
          }

          showSilentUpdateNotification() {
            // Show a brief, non-intrusive notification
            const notification = document.createElement("div");
            notification.className =
              "fixed bottom-4 left-4 z-50 bg-green-500 text-white px-4 py-2 rounded-lg text-sm font-medium shadow-lg transition-all duration-300 transform translate-y-full";
            notification.innerHTML = `
              <div class="flex items-center gap-2">
                <i class="fas fa-check"></i>
                <span>App updated successfully</span>
              </div>
            `;

            document.body.appendChild(notification);

            // Animate in
            setTimeout(() => {
              notification.classList.remove("translate-y-full");
            }, 100);

            // Auto remove after 3 seconds
            setTimeout(() => {
              notification.classList.add("translate-y-full");
              setTimeout(() => {
                if (notification.parentNode) {
                  notification.parentNode.removeChild(notification);
                }
              }, 300);
            }, 3000);
          }

          setupInstallPrompt() {
            // Listen for beforeinstallprompt event (mobile and some desktop browsers)
            window.addEventListener("beforeinstallprompt", (e) => {
              console.log("💾 PWA install prompt available");
              e.preventDefault();
              this.installPrompt = e;
              this.showInstallBanner();
            });

            // Check for manual install conditions (desktop browsers)
            this.checkForManualInstall();

            // Handle install button click
            document
              .getElementById("install-pwa-btn")
              ?.addEventListener("click", () => {
                this.installPWA();
              });

            // Handle dismiss button click
            document
              .getElementById("dismiss-pwa-btn")
              ?.addEventListener("click", () => {
                this.hideInstallBanner();
              });

            // Check if already installed
            if (
              window.matchMedia &&
              window.matchMedia("(display-mode: standalone)").matches
            ) {
              console.log("📱 PWA is already installed");
              // Hide install banner as app is already installed
              this.hideInstallBanner();
            }
          }

          checkForManualInstall() {
            // Don't show if already installed
            const isStandalone =
              window.matchMedia &&
              window.matchMedia("(display-mode: standalone)").matches;
            const isIOSStandalone = window.navigator.standalone === true;

            if (isStandalone || isIOSStandalone) {
              return;
            }

            // Check if user has already dismissed manual install
            const dismissedManualInstall = localStorage.getItem(
              "dismissed-manual-install"
            );
            const dismissedTime = dismissedManualInstall
              ? parseInt(dismissedManualInstall)
              : 0;
            const now = Date.now();
            const DISMISS_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days

            if (dismissedTime && now - dismissedTime < DISMISS_DURATION) {
              console.log("📱 Manual install dismissed recently");
              return;
            }

            // Detect browser and platform
            const userAgent = navigator.userAgent;
            const isDesktop =
              !/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                userAgent
              );
            const isMobile = !isDesktop;
            const isChrome =
              /Chrome/i.test(userAgent) && !/Edge|OPR/i.test(userAgent);
            const isEdge = /Edge/i.test(userAgent);
            const isFirefox = /Firefox/i.test(userAgent);
            const isSafari =
              /Safari/i.test(userAgent) && !/Chrome|Edge|OPR/i.test(userAgent);

            // Check if PWA features are supported
            const supportsPWA =
              "serviceWorker" in navigator && "manifestJSON" in window;

            // Show manual install for browsers that support PWA or can benefit from it
            if (
              (isDesktop && (isChrome || isEdge)) ||
              (isMobile && (isChrome || isEdge || isSafari)) ||
              isFirefox
            ) {
              console.log(
                `🖥️ ${
                  isDesktop ? "Desktop" : "Mobile"
                } browser detected (${this.getBrowserName()}), showing manual install guide`
              );
              setTimeout(() => {
                this.showManualInstallBanner();
              }, 5000); // Show after 5 seconds to not be intrusive
            } else {
              console.log("🌐 Browser doesn't support PWA installation");
            }
          }

          getBrowserName() {
            const userAgent = navigator.userAgent;
            if (/Chrome/i.test(userAgent) && !/Edge|OPR/i.test(userAgent))
              return "Chrome";
            if (/Edge/i.test(userAgent)) return "Edge";
            if (/Firefox/i.test(userAgent)) return "Firefox";
            if (
              /Safari/i.test(userAgent) &&
              !/Chrome|Edge|OPR/i.test(userAgent)
            )
              return "Safari";
            if (/OPR/i.test(userAgent)) return "Opera";
            return "Unknown";
          }

          showManualInstallBanner() {
            const banner = document.getElementById("pwa-banner");
            if (banner) {
              // Update banner content for manual install
              const userAgent = navigator.userAgent;
              const isChrome =
                /Chrome/i.test(userAgent) && !/Edge|OPR/i.test(userAgent);
              const isEdge = /Edge/i.test(userAgent);
              const isFirefox = /Firefox/i.test(userAgent);

              let instructions = "";
              if (isChrome) {
                instructions =
                  "Click the install icon in the address bar or go to Settings → Install Prayer Times";
              } else if (isEdge) {
                instructions =
                  "Click the install icon in the address bar or go to Settings → Apps → Install this site as an app";
              } else if (isFirefox) {
                instructions =
                  "Bookmark this page and add it to your home screen for easy access";
              } else {
                instructions =
                  "Add this page to your bookmarks for quick access";
              }

              banner.innerHTML = `
                <div class="flex items-start justify-between p-4 text-white">
                  <div class="flex items-start gap-3 flex-1">
                    <i class="fas fa-download text-xl mt-1"></i>
                    <div class="flex-1">
                      <p class="font-semibold mb-1">Install Prayer Times App</p>
                      <p class="text-sm opacity-90 mb-2">Get faster access and offline support</p>
                      <p class="text-xs opacity-80 bg-white bg-opacity-10 p-2 rounded">
                        <i class="fas fa-info-circle mr-1"></i>
                        ${instructions}
                      </p>
                    </div>
                  </div>
                  <div class="flex items-center gap-2 ml-4">
                    <button id="manual-install-btn" class="bg-yellow-500 text-gray-900 px-4 py-2 rounded-lg font-semibold hover:bg-yellow-400 transition-colors text-sm">
                      Show Guide
                    </button>
                    <button id="dismiss-manual-btn" class="text-white hover:text-yellow-300 p-2">
                      <i class="fas fa-times"></i>
                    </button>
                  </div>
                </div>
              `;

              banner.classList.remove("hidden");
              setTimeout(() => banner.classList.add("show"), 100);

              // Handle manual install guide button
              document
                .getElementById("manual-install-btn")
                ?.addEventListener("click", () => {
                  this.showInstallGuide();
                });

              // Handle dismiss button
              document
                .getElementById("dismiss-manual-btn")
                ?.addEventListener("click", () => {
                  this.dismissManualInstall();
                });
            }
          }

          showInstallGuide() {
            const userAgent = navigator.userAgent;
            const isChrome =
              /Chrome/i.test(userAgent) && !/Edge|OPR/i.test(userAgent);
            const isEdge = /Edge/i.test(userAgent);
            const isFirefox = /Firefox/i.test(userAgent);
            const isSafari =
              /Safari/i.test(userAgent) && !/Chrome|Edge|OPR/i.test(userAgent);
            const isMobile =
              /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
                userAgent
              );

            let guideContent = "";

            if (isChrome) {
              guideContent = `
                <div class="space-y-4">
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">1</div>
                    <div>
                      <p class="font-semibold">Look for the install icon</p>
                      <p class="text-sm opacity-80">Find the <i class="fas fa-plus-square"></i> or <i class="fas fa-download"></i> icon in your address bar</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">2</div>
                    <div>
                      <p class="font-semibold">Click to install</p>
                      <p class="text-sm opacity-80">Or go to Chrome menu → More tools → Create shortcut</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white font-bold">✓</div>
                    <div>
                      <p class="font-semibold">Enjoy the app!</p>
                      <p class="text-sm opacity-80">Prayer Times will now work offline and load faster</p>
                    </div>
                  </div>
                </div>
              `;
            } else if (isEdge) {
              guideContent = `
                <div class="space-y-4">
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">1</div>
                    <div>
                      <p class="font-semibold">Look for the app icon</p>
                      <p class="text-sm opacity-80">Find the <i class="fas fa-plus"></i> icon in your address bar</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">2</div>
                    <div>
                      <p class="font-semibold">Click "Install Prayer Times"</p>
                      <p class="text-sm opacity-80">Or go to Settings menu → Apps → Install this site as an app</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white font-bold">✓</div>
                    <div>
                      <p class="font-semibold">App installed!</p>
                      <p class="text-sm opacity-80">Find it in your Start menu or desktop</p>
                    </div>
                  </div>
                </div>
              `;
            } else if (isSafari && isMobile) {
              guideContent = `
                <div class="space-y-4">
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">1</div>
                    <div>
                      <p class="font-semibold">Tap the Share button</p>
                      <p class="text-sm opacity-80">Look for <i class="fas fa-share"></i> at the bottom of Safari</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">2</div>
                    <div>
                      <p class="font-semibold">Add to Home Screen</p>
                      <p class="text-sm opacity-80">Scroll down and tap "Add to Home Screen"</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">3</div>
                    <div>
                      <p class="font-semibold">Confirm installation</p>
                      <p class="text-sm opacity-80">Tap "Add" to install Prayer Times app</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white font-bold">✓</div>
                    <div>
                      <p class="font-semibold">App ready!</p>
                      <p class="text-sm opacity-80">Find the Prayer Times app icon on your home screen</p>
                    </div>
                  </div>
                </div>
              `;
            } else if (isFirefox) {
              guideContent = `
                <div class="space-y-4">
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-orange-500 rounded-full flex items-center justify-center text-white font-bold">1</div>
                    <div>
                      <p class="font-semibold">Bookmark this page</p>
                      <p class="text-sm opacity-80">Press Ctrl+D (or Cmd+D on Mac) to bookmark</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-orange-500 rounded-full flex items-center justify-center text-white font-bold">2</div>
                    <div>
                      <p class="font-semibold">Add to bookmarks toolbar</p>
                      <p class="text-sm opacity-80">For quick access from your toolbar</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white font-bold">✓</div>
                    <div>
                      <p class="font-semibold">Quick access ready!</p>
                      <p class="text-sm opacity-80">Click the bookmark for instant prayer times</p>
                    </div>
                  </div>
                </div>
              `;
            } else {
              guideContent = `
                <div class="space-y-4">
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-blue-500 rounded-full flex items-center justify-center text-white font-bold">1</div>
                    <div>
                      <p class="font-semibold">Bookmark this page</p>
                      <p class="text-sm opacity-80">Add it to your favorites for easy access</p>
                    </div>
                  </div>
                  <div class="flex items-center gap-3 p-3 bg-white bg-opacity-10 rounded-lg">
                    <div class="w-8 h-8 bg-green-500 rounded-full flex items-center justify-center text-white font-bold">✓</div>
                    <div>
                      <p class="font-semibold">Quick access ready!</p>
                      <p class="text-sm opacity-80">Visit anytime for accurate prayer times</p>
                    </div>
                  </div>
                </div>
              `;
            }

            // Create modal overlay
            const modal = document.createElement("div");
            modal.className =
              "fixed inset-0 z-50 flex items-center justify-center p-4";
            modal.style.background = "rgba(0, 0, 0, 0.8)";
            modal.innerHTML = `
              <div class="glass-morphism rounded-3xl p-6 max-w-md w-full text-white">
                <div class="text-center mb-6">
                  <div class="inline-flex items-center justify-center w-16 h-16 bg-gradient-to-r from-yellow-500 to-yellow-600 rounded-full mb-4">
                    <i class="fas fa-mobile-alt text-2xl text-white"></i>
                  </div>
                  <h3 class="text-2xl font-bold mb-2">Install Prayer Times</h3>
                  <p class="text-sm opacity-80">Follow these simple steps</p>
                </div>
                
                ${guideContent}
                
                <div class="mt-6 flex gap-3">
                  <button id="got-it-btn" class="flex-1 bg-gradient-to-r from-green-500 to-green-600 text-white px-4 py-3 rounded-lg font-semibold hover:from-green-600 hover:to-green-700 transition-all">
                    Got it!
                  </button>
                  <button id="close-guide-btn" class="px-4 py-3 border border-white border-opacity-30 rounded-lg hover:bg-white hover:bg-opacity-10 transition-all">
                    Close
                  </button>
                </div>
              </div>
            `;

            document.body.appendChild(modal);

            // Handle close buttons
            const closeGuide = () => {
              modal.style.opacity = "0";
              setTimeout(() => {
                if (modal.parentNode) {
                  modal.parentNode.removeChild(modal);
                }
              }, 300);
            };

            document
              .getElementById("got-it-btn")
              ?.addEventListener("click", () => {
                this.dismissManualInstall();
                closeGuide();
              });

            document
              .getElementById("close-guide-btn")
              ?.addEventListener("click", closeGuide);
            modal.addEventListener("click", (e) => {
              if (e.target === modal) closeGuide();
            });
          }

          dismissManualInstall() {
            localStorage.setItem(
              "dismissed-manual-install",
              Date.now().toString()
            );
            this.hideInstallBanner();
          }

          setupDateChecker() {
            // Store the current date when the page loads
            const loadDate = new Date().toDateString();
            console.log("📅 PWA loaded on:", loadDate);

            // Check every 30 seconds if the date has changed
            setInterval(() => {
              const currentDate = new Date().toDateString();

              if (currentDate !== loadDate) {
                console.log(
                  "📅 Date changed detected! Reloading page for fresh data..."
                );
                console.log(
                  "🔄 Old date:",
                  loadDate,
                  "→ New date:",
                  currentDate
                );

                // Show a brief notification before reload
                this.showDateChangeReload();

                // Reload after a short delay to show the notification
                setTimeout(() => {
                  window.location.reload();
                }, 1500);
              }
            }, 30000); // Check every 30 seconds

            console.log(
              "⏰ Date change monitoring enabled for PWA auto-refresh"
            );
          }

          showDateChangeReload() {
            // Create and show a notification that the page is reloading due to date change
            const notification = document.createElement("div");
            notification.className =
              "fixed top-4 left-1/2 transform -translate-x-1/2 z-50 bg-gradient-to-r from-blue-500 to-indigo-600 text-white px-6 py-3 rounded-lg shadow-lg transition-all duration-300 opacity-0";
            notification.innerHTML = `
              <div class="flex items-center gap-3">
                <i class="fas fa-calendar-day text-lg"></i>
                <div>
                  <div class="font-semibold">New Day Detected</div>
                  <div class="text-sm opacity-90">Refreshing for today's prayer times...</div>
                </div>
                <div class="ml-2">
                  <i class="fas fa-sync-alt animate-spin"></i>
                </div>
              </div>
            `;

            document.body.appendChild(notification);

            // Fade in
            setTimeout(() => {
              notification.style.opacity = "1";
            }, 100);
          }

          async installPWA() {
            if (!this.installPrompt) {
              console.log(
                "📱 No automatic install prompt available, showing manual guide"
              );
              this.showInstallGuide();
              return;
            }

            try {
              // Show the install prompt
              this.installPrompt.prompt();

              // Wait for user choice
              const choiceResult = await this.installPrompt.userChoice;

              if (choiceResult.outcome === "accepted") {
                console.log("✅ User accepted PWA install");
                this.hideInstallBanner();

                // Track installation
                this.trackPWAInstall();
              } else {
                console.log("❌ User dismissed PWA install");
              }

              // Clear the prompt
              this.installPrompt = null;
            } catch (error) {
              console.error("PWA install error:", error);
              // Fallback to manual guide
              this.showInstallGuide();
            }
          }

          showInstallBanner() {
            const banner = document.getElementById("pwa-banner");
            if (banner) {
              banner.classList.remove("hidden");
              setTimeout(() => banner.classList.add("show"), 100);
            }
          }

          hideInstallBanner() {
            const banner = document.getElementById("pwa-banner");
            if (banner) {
              banner.classList.remove("show");
              setTimeout(() => banner.classList.add("hidden"), 500);
            }
          }

          showUpdateBanner() {
            const banner = document.getElementById("update-banner");
            if (banner) {
              banner.classList.remove("hidden");
              setTimeout(() => banner.classList.add("show"), 100);

              // Update the text to be more specific for PWA users
              const titleElement = banner.querySelector("p.font-semibold");
              const descElement = banner.querySelector("p.text-sm");
              if (titleElement)
                titleElement.textContent = "PWA Update Available";
              if (descElement)
                descElement.textContent =
                  "Restart the app to get the latest features";
            }

            // Handle update button click (remove any existing listeners first)
            const updateBtn = document.getElementById("update-app-btn");
            if (updateBtn) {
              const newUpdateBtn = updateBtn.cloneNode(true);
              updateBtn.parentNode.replaceChild(newUpdateBtn, updateBtn);

              newUpdateBtn.addEventListener("click", () => {
                this.updateApp();
              });
            }

            // Handle dismiss button click (remove any existing listeners first)
            const dismissBtn = document.getElementById("dismiss-update-btn");
            if (dismissBtn) {
              const newDismissBtn = dismissBtn.cloneNode(true);
              dismissBtn.parentNode.replaceChild(newDismissBtn, dismissBtn);

              newDismissBtn.addEventListener("click", () => {
                this.hideUpdateBanner();
              });
            }
          }

          hideUpdateBanner() {
            const banner = document.getElementById("update-banner");
            if (banner) {
              banner.classList.remove("show");
              setTimeout(() => banner.classList.add("hidden"), 500);
            }
          }

          async updateApp() {
            if (this.swRegistration && this.swRegistration.waiting) {
              // Tell the waiting service worker to skip waiting and become active
              this.swRegistration.waiting.postMessage({ type: "SKIP_WAITING" });

              // Reload the page to use the new service worker
              window.location.reload();
            }
          }

          trackPWAInstall() {
            // Track PWA installation (could be sent to analytics)
            console.log("📊 PWA installed successfully");

            // Store install date
            localStorage.setItem(
              "pwa-installed-date",
              new Date().toISOString()
            );
          }

          setupAutoRefresh() {
            // Store the current date to detect day changes
            let currentDate = new Date().toDateString();

            // Check every minute if the day has changed
            setInterval(() => {
              const newDate = new Date().toDateString();

              if (newDate !== currentDate) {
                currentDate = newDate;
                console.log("📅 Day changed, refreshing today's prayer times");

                // If user is currently viewing "today", refresh the data
                const periodSelect = document.getElementById("period-select");
                if (periodSelect && periodSelect.value === "today") {
                  // Clear cache for today's data to force fresh fetch
                  if (window.azanCache) {
                    const locationSelect =
                      document.getElementById("location-select");
                    if (locationSelect && locationSelect.value) {
                      const cacheKey = `${locationSelect.value}/today.json`;
                      window.azanCache.cache.delete(cacheKey);
                      console.log("🗑️ Cleared today's cache for fresh data");
                    }
                  }

                  // Trigger refresh by dispatching change event
                  periodSelect.dispatchEvent(new Event("change"));

                  // Show subtle notification
                  this.showDayChangeNotification();
                }
              }
            }, 60000); // Check every minute

            console.log("⏰ Auto-refresh for today's data enabled");
          }

          showDayChangeNotification() {
            // Create and show a subtle notification that today's data has been updated
            const notification = document.createElement("div");
            notification.className =
              "fixed top-4 right-4 z-50 bg-gradient-to-r from-green-500 to-blue-500 text-white px-4 py-2 rounded-lg shadow-lg transform translate-x-full transition-transform duration-300";
            notification.innerHTML = `
              <div class="flex items-center gap-2">
                <i class="fas fa-sync-alt text-sm"></i>
                <span class="text-sm font-medium">Today's prayer times updated</span>
              </div>
            `;

            document.body.appendChild(notification);

            // Slide in
            setTimeout(() => {
              notification.classList.remove("translate-x-full");
            }, 100);

            // Slide out and remove after 3 seconds
            setTimeout(() => {
              notification.classList.add("translate-x-full");
              setTimeout(() => {
                if (notification.parentNode) {
                  notification.parentNode.removeChild(notification);
                }
              }, 300);
            }, 3000);
          }

          loadUserPreferences() {
            // Load default location from localStorage
            try {
              const saved = localStorage.getItem(
                "prayer-times-default-location"
              );
              if (saved) {
                defaultLocation = JSON.parse(saved);
                console.log(
                  "📍 Loaded default location:",
                  defaultLocation.name
                );
              }
            } catch (error) {
              console.warn("Failed to load user preferences:", error);
            }
          }
        }

        // 💾 LOCATION PREFERENCES MANAGER
        class LocationPreferencesManager {
          constructor() {
            this.setupEventListeners();
          }

          setupEventListeners() {
            // No event listeners needed - automatic saving is handled in main location change event
          }

          saveDefaultLocation() {
            if (!selectedLocation) {
              this.showMessage("Please select a location first", "error");
              return;
            }

            try {
              const locationData = {
                value: selectedLocation,
                name: this.getLocationDisplayName(selectedLocation),
                savedAt: new Date().toISOString(),
              };

              localStorage.setItem(
                "prayer-times-default-location",
                JSON.stringify(locationData)
              );
              defaultLocation = locationData;

              this.updateLocationUI();

              console.log("💾 Default location saved:", locationData.name);
            } catch (error) {
              console.error("Failed to save default location:", error);
              this.showMessage("Failed to save location", "error");
            }
          }

          loadDefaultLocation() {
            if (defaultLocation && !selectedLocation) {
              // Set the default location
              const locationSelect = document.getElementById("location");
              if (locationSelect) {
                locationSelect.value = defaultLocation.value;
                selectedLocation = defaultLocation.value;

                // Trigger change event to load prayer data
                locationSelect.dispatchEvent(new Event("change"));

                this.updateLocationUI();
                console.log(
                  "✅ Default location loaded:",
                  defaultLocation.name
                );
              }
            }
          }

          updateLocationUI() {
            // No UI updates needed - automatic saving handles everything
          }

          getLocationDisplayName(locationValue) {
            const option = document.querySelector(
              `#location option[value="${locationValue}"]`
            );
            return option ? option.textContent : locationValue;
          }

          clearDefaultLocation() {
            try {
              localStorage.removeItem("prayer-times-default-location");
              defaultLocation = null;
              this.updateLocationUI();
              this.showMessage("Default location cleared", "info");
            } catch (error) {
              console.error("Failed to clear default location:", error);
            }
          }

          showMessage(message, type = "info") {
            // Create and show a temporary message
            const messageDiv = document.createElement("div");
            messageDiv.className = `fixed top-20 right-4 z-50 px-4 py-2 rounded-lg text-white text-sm font-medium shadow-lg transition-all duration-300 transform translate-x-full`;

            // Style based on type
            switch (type) {
              case "success":
                messageDiv.classList.add("bg-green-500");
                break;
              case "error":
                messageDiv.classList.add("bg-red-500");
                break;
              case "warning":
                messageDiv.classList.add("bg-yellow-500");
                break;
              default:
                messageDiv.classList.add("bg-blue-500");
            }

            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            // Animate in
            setTimeout(() => {
              messageDiv.classList.remove("translate-x-full");
            }, 100);

            // Auto remove after 3 seconds
            setTimeout(() => {
              messageDiv.classList.add("translate-x-full");
              setTimeout(() => {
                if (messageDiv.parentNode) {
                  messageDiv.parentNode.removeChild(messageDiv);
                }
              }, 300);
            }, 3000);
          }
        }

        // Initialize PWA and preferences managers
        const pwaManager = new PWAManager();
        const preferencesManager = new LocationPreferencesManager();

        // Export for debugging
        window.pwaManager = pwaManager;
        window.preferencesManager = preferencesManager;

        // 🚀 EXISTING CODE CONTINUES HERE...

        const periods = [
          { value: "today", label: "Today" },
          { value: "month", label: "This Month" },
          { value: "year", label: "This Year" },
        ];

        let locations = [];
        let selectedLocation = null;
        let selectedPeriod = "today";
        let geocodeCache = new Map(); // Will be replaced with advanced cache
        let isAutoDetecting = false;

        // 🚀 ADVANCED CACHING & PERFORMANCE SYSTEM

        // Enhanced cache with metadata and compression
        class AdvancedLocationCache {
          constructor() {
            this.cache = new Map();
            this.metadata = new Map(); // Store cache metadata
            this.compressionEnabled = this.supportsCompression();
            this.maxCacheSize = 500; // Maximum cached locations
            this.cacheVersion = "2.0"; // For cache invalidation
            this.init();
          }

          init() {
            this.loadFromStorage();
            this.setupAutoCleanup();
            console.log(
              `🏎️ Advanced cache initialized: ${this.cache.size} locations loaded`
            );
          }

          supportsCompression() {
            try {
              return "CompressionStream" in window || "pako" in window;
            } catch {
              return false;
            }
          }

          async set(key, value, metadata = {}) {
            const entry = {
              data: value,
              timestamp: Date.now(),
              hits: 0,
              lastAccessed: Date.now(),
              size: JSON.stringify(value).length,
              ...metadata,
            };

            this.cache.set(key, value);
            this.metadata.set(key, entry);

            // Automatic cache size management
            if (this.cache.size > this.maxCacheSize) {
              await this.evictLeastUsed();
            }

            // Async persistence
            this.persistToStorage();
          }

          get(key) {
            if (this.cache.has(key)) {
              const metadata = this.metadata.get(key);
              if (metadata) {
                metadata.hits++;
                metadata.lastAccessed = Date.now();
              }
              return this.cache.get(key);
            }
            return null;
          }

          has(key) {
            return this.cache.has(key);
          }

          async evictLeastUsed() {
            const entries = Array.from(this.metadata.entries()).sort((a, b) => {
              // Sort by frequency and recency
              const scoreA =
                a[1].hits * 0.7 + (Date.now() - a[1].lastAccessed) * -0.3;
              const scoreB =
                b[1].hits * 0.7 + (Date.now() - b[1].lastAccessed) * -0.3;
              return scoreA - scoreB;
            });

            const toEvict = entries.slice(
              0,
              Math.floor(this.maxCacheSize * 0.2)
            ); // Remove 20%

            for (const [key] of toEvict) {
              this.cache.delete(key);
              this.metadata.delete(key);
            }

            console.log(`🧹 Cache cleanup: removed ${toEvict.length} entries`);
          }

          async loadFromStorage() {
            try {
              const [cacheData, metadataData, version] = await Promise.all([
                this.getStorageItem("azanLocationCacheV2"),
                this.getStorageItem("azanLocationMetadataV2"),
                this.getStorageItem("azanLocationCacheVersionV2"),
              ]);

              if (version !== this.cacheVersion) {
                console.log("🔄 Cache version mismatch, clearing old cache");
                this.clearStorage();
                return;
              }

              if (cacheData && metadataData) {
                const cacheEntries = JSON.parse(cacheData);
                const metadataEntries = JSON.parse(metadataData);

                this.cache = new Map(cacheEntries);
                this.metadata = new Map(metadataEntries);

                console.log(
                  `� Loaded ${this.cache.size} locations from advanced cache`
                );
              }
            } catch (error) {
              console.warn("Failed to load cache:", error);
              this.clearStorage();
            }
          }

          async persistToStorage() {
            try {
              const cacheEntries = Array.from(this.cache.entries());
              const metadataEntries = Array.from(this.metadata.entries());

              await Promise.all([
                this.setStorageItem(
                  "azanLocationCacheV2",
                  JSON.stringify(cacheEntries)
                ),
                this.setStorageItem(
                  "azanLocationMetadataV2",
                  JSON.stringify(metadataEntries)
                ),
                this.setStorageItem(
                  "azanLocationCacheVersionV2",
                  this.cacheVersion
                ),
              ]);
            } catch (error) {
              console.warn("Failed to persist cache:", error);
            }
          }

          async getStorageItem(key) {
            return localStorage.getItem(key);
          }

          async setStorageItem(key, value) {
            localStorage.setItem(key, value);
          }

          setupAutoCleanup() {
            // Clean up expired entries every 5 minutes
            setInterval(() => {
              this.cleanupExpired();
            }, 5 * 60 * 1000);
          }

          cleanupExpired() {
            const now = Date.now();
            const maxAge = 7 * 24 * 60 * 60 * 1000; // 7 days
            let cleaned = 0;

            for (const [key, metadata] of this.metadata.entries()) {
              if (now - metadata.timestamp > maxAge) {
                this.cache.delete(key);
                this.metadata.delete(key);
                cleaned++;
              }
            }

            if (cleaned > 0) {
              console.log(`🧹 Cleaned ${cleaned} expired cache entries`);
              this.persistToStorage();
            }
          }

          clearStorage() {
            [
              "azanLocationCacheV2",
              "azanLocationMetadataV2",
              "azanLocationCacheVersionV2",
            ].forEach((key) => {
              localStorage.removeItem(key);
            });
            this.cache.clear();
            this.metadata.clear();
          }

          getStats() {
            const totalSize = Array.from(this.metadata.values()).reduce(
              (sum, meta) => sum + meta.size,
              0
            );

            return {
              size: this.cache.size,
              totalSizeKB: Math.round(totalSize / 1024),
              hitRate: this.calculateHitRate(),
              oldestEntry: this.getOldestEntry(),
              mostUsed: this.getMostUsedEntry(),
            };
          }

          calculateHitRate() {
            const entries = Array.from(this.metadata.values());
            if (entries.length === 0) return 0;

            const totalHits = entries.reduce((sum, meta) => sum + meta.hits, 0);
            return totalHits / entries.length;
          }

          getOldestEntry() {
            let oldest = null;
            let oldestTime = Date.now();

            for (const [key, metadata] of this.metadata.entries()) {
              if (metadata.timestamp < oldestTime) {
                oldestTime = metadata.timestamp;
                oldest = key;
              }
            }

            return oldest;
          }

          getMostUsedEntry() {
            let mostUsed = null;
            let maxHits = 0;

            for (const [key, metadata] of this.metadata.entries()) {
              if (metadata.hits > maxHits) {
                maxHits = metadata.hits;
                mostUsed = key;
              }
            }

            return { key: mostUsed, hits: maxHits };
          }
        }

        // Performance monitoring and optimization
        class PerformanceMonitor {
          constructor() {
            this.metrics = new Map();
            this.enabled = true;
          }

          startTiming(operation) {
            if (!this.enabled) return null;

            const id = `${operation}_${Date.now()}_${Math.random()}`;
            this.metrics.set(id, {
              operation,
              startTime: performance.now(),
              startMemory: this.getMemoryUsage(),
            });
            return id;
          }

          endTiming(id) {
            if (!this.enabled || !this.metrics.has(id)) return null;

            const metric = this.metrics.get(id);
            const endTime = performance.now();
            const endMemory = this.getMemoryUsage();

            const result = {
              operation: metric.operation,
              duration: endTime - metric.startTime,
              memoryDelta: endMemory - metric.startMemory,
              timestamp: new Date().toISOString(),
            };

            this.metrics.delete(id);
            this.logPerformance(result);
            return result;
          }

          getMemoryUsage() {
            try {
              return performance.memory ? performance.memory.usedJSHeapSize : 0;
            } catch {
              return 0;
            }
          }

          logPerformance(result) {
            if (result.duration > 1000) {
              // Log operations > 1 second
              console.log(
                `⚡ Performance: ${
                  result.operation
                } took ${result.duration.toFixed(2)}ms`
              );
            }
          }

          getAverageTime(operation) {
            // This would track historical performance data
            return 0;
          }
        }

        // Initialize advanced systems
        const advancedCache = new AdvancedLocationCache();
        const performanceMonitor = new PerformanceMonitor();

        // Replace simple cache with advanced cache
        geocodeCache = advancedCache;

        // Enhanced cache utilities with advanced features
        window.azanCache = {
          stats: () => advancedCache.getStats(),
          clear: () => advancedCache.clearStorage(),
          size: () => advancedCache.cache.size,
          performance: () => performanceMonitor.metrics,
          evict: () => advancedCache.evictLeastUsed(),

          // Advanced debugging utilities
          inspect: (key) => ({
            cached: advancedCache.has(key),
            metadata: advancedCache.metadata.get(key),
            data: advancedCache.get(key),
          }),

          // Cache health check
          health: () => {
            const stats = advancedCache.getStats();
            return {
              healthy: stats.size > 0 && stats.hitRate > 0.5,
              recommendations:
                stats.size === 0
                  ? ["Cache is empty"]
                  : stats.hitRate < 0.3
                  ? ["Low hit rate - consider cache warming"]
                  : ["Cache is performing well"],
            };
          },
        };

        const locationSelect = document.getElementById("location");
        const periodButtonsDiv = document.getElementById("period-buttons");
        const loadingDiv = document.getElementById("loading");
        const errorDiv = document.getElementById("error");
        const prayerDataDiv = document.getElementById("prayer-data");

        // 🚀 WORLD-CLASS AUTO-DETECTION OPTIMIZATION

        // Advanced location similarity scoring for better matches
        class LocationMatcher {
          static levenshteinDistance(a, b) {
            const dp = Array(a.length + 1)
              .fill()
              .map(() => Array(b.length + 1).fill(0));

            for (let i = 0; i <= a.length; i++) dp[i][0] = i;
            for (let j = 0; j <= b.length; j++) dp[0][j] = j;

            for (let i = 1; i <= a.length; i++) {
              for (let j = 1; j <= b.length; j++) {
                if (a[i - 1] === b[j - 1]) {
                  dp[i][j] = dp[i - 1][j - 1];
                } else {
                  dp[i][j] =
                    1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);
                }
              }
            }
            return dp[a.length][b.length];
          }

          static similarity(str1, str2) {
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            if (longer.length === 0) return 1.0;

            const distance = this.levenshteinDistance(longer, shorter);
            return (longer.length - distance) / longer.length;
          }

          static fuzzyMatch(query, candidates) {
            return candidates
              .map((candidate) => ({
                candidate,
                score: this.similarity(
                  query.toLowerCase(),
                  candidate.toLowerCase()
                ),
              }))
              .filter((item) => item.score > 0.6)
              .sort((a, b) => b.score - a.score);
          }
        }

        // Smart location preprocessing with context awareness
        class LocationProcessor {
          static cleanLocationName(locationName, attempt = 1) {
            const stopWords = [
              "HANAFI",
              "SHAFI",
              "SAMASTHA",
              "MARKAZ",
              "CHANDRIKA",
              "ALBUSTHAN",
              "SUNNI",
              "JAMIYYATHUL",
              "MUALLIMEEN",
              "Assembly",
              "Constituency",
              "District",
              "Taluk",
              "Corporation",
              "Municipality",
              "Panchayat",
              "Town",
              "City",
              "Village",
              "North",
              "South",
              "East",
              "West",
              "Market_Pally",
              "Eriyad_Special",
              "Luhar",
              "KKPJ",
              "EKM",
              "UK",
              "TVM",
            ];

            const timePatterns = [
              /12:40_Fixed/gi,
              /ROUND_FIGURE/gi,
              /ORIGIN_80/gi,
              /Magrib_Isha/gi,
              /OG/gi,
              /standard_to_thambaanur/gi,
              /PAIPPAD_ISLAMIC_FINDER/gi,
              /PADUBIDRI/gi,
              /\b\d{4}\b/g,
            ];

            let query = locationName.replace(/_/g, " ");

            // Remove Islamic/administrative terms
            stopWords.forEach((word) => {
              query = query.replace(new RegExp(word, "gi"), "");
            });

            // Remove time patterns
            timePatterns.forEach((pattern) => {
              query = query.replace(pattern, "");
            });

            // Clean punctuation and extra spaces
            query = query
              .replace(/\([^)]*\)/g, "")
              .replace(/[-_]+/g, " ")
              .replace(/\s+/g, " ")
              .trim();

            // Multi-attempt strategy
            if (attempt === 2) {
              const parts = locationName.split("_");
              query = parts[0].replace(/[^a-zA-Z]/g, "");
            } else if (attempt === 3) {
              const parts = locationName.split("_");
              query =
                parts.length > 1 ? parts[1].replace(/[^a-zA-Z]/g, "") : "";
            }

            return query.length >= 3 ? query : null;
          }

          static generateSearchVariants(cleanedName) {
            const variants = [
              `${cleanedName}, Kerala, India`,
              `${cleanedName}, Kerala`,
              `${cleanedName} Kerala`,
              cleanedName,
            ];

            // Add common suffixes for Kerala locations
            const suffixes = ["Panchayat", "Municipality", "Corporation"];
            suffixes.forEach((suffix) => {
              variants.push(`${cleanedName} ${suffix}, Kerala, India`);
            });

            return [...new Set(variants)]; // Remove duplicates
          }
        }

        // Advanced geocoding with multiple fallback strategies
        async function geocodeLocation(locationName, attempt = 1) {
          // Check cache first
          if (geocodeCache.has(locationName)) {
            return geocodeCache.get(locationName);
          }

          try {
            const cleanedName = LocationProcessor.cleanLocationName(
              locationName,
              attempt
            );
            if (!cleanedName) return null;

            const searchVariants =
              LocationProcessor.generateSearchVariants(cleanedName);

            // Try each search variant until we find results
            for (const searchQuery of searchVariants) {
              const coords = await this.tryGeocode(searchQuery, attempt);
              if (coords) {
                // Cache successful result with advanced caching
                await geocodeCache.set(locationName, coords, {
                  source: "nominatim",
                  quality: coords.confidence || 0.8,
                  searchQuery: searchQuery,
                });
                return coords;
              }
            }

            // Recursive retry with next attempt
            if (attempt < 3) {
              return await geocodeLocation(locationName, attempt + 1);
            }

            return null;
          } catch (error) {
            console.warn(
              `Geocoding attempt ${attempt} failed for ${locationName}:`,
              error
            );
            if (attempt < 3) {
              return await geocodeLocation(locationName, attempt + 1);
            }
            return null;
          }
        }

        // Optimized geocoding with intelligent result selection
        async function tryGeocode(searchQuery, attempt) {
          const urls = [
            // Primary: Nominatim with Kerala focus (using q parameter only)
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
              searchQuery
            )}&limit=5&countrycodes=in`,
            // Fallback: General India search
            `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
              searchQuery
            )}&limit=3&countrycodes=in`,
          ];

          // Exponential backoff delay
          const delay = Math.min(200 * Math.pow(1.5, attempt - 1), 2000);
          await new Promise((resolve) => setTimeout(resolve, delay));

          for (const url of urls) {
            try {
              const response = await fetch(url, {
                headers: {
                  "User-Agent": "Kerala Prayer Times (contact@azantimes.in)",
                },
                signal: AbortSignal.timeout(8000), // 8 second timeout
              });

              if (!response.ok) {
                console.warn(
                  `Geocoding API returned ${response.status} for: ${url}`
                );
                continue;
              }

              const data = await response.json();

              // Check for API error responses
              if (data.error) {
                console.warn(
                  `Geocoding API error: ${data.error.message} for: ${url}`
                );
                continue;
              }

              if (data.length > 0) {
                // Intelligent result selection
                const bestMatch = this.selectBestGeocodingResult(
                  data,
                  searchQuery
                );
                if (bestMatch) {
                  return {
                    lat: parseFloat(bestMatch.lat),
                    lon: parseFloat(bestMatch.lon),
                    confidence: bestMatch.confidence || 0.8,
                  };
                }
              }
            } catch (error) {
              console.warn(`Geocoding URL failed: ${url}`, error);
              continue;
            }
          }

          return null;
        }

        // Smart result selection based on relevance scoring
        function selectBestGeocodingResult(results, originalQuery) {
          const scoredResults = results.map((result) => {
            let score = 0;
            const displayName = result.display_name.toLowerCase();
            const query = originalQuery.toLowerCase();

            // Kerala preference (highest priority)
            if (displayName.includes("kerala")) score += 100;

            // Exact name match
            if (displayName.includes(query.split(",")[0].trim())) score += 50;

            // Location type preferences
            if (result.type === "city" || result.type === "town") score += 30;
            else if (result.type === "village") score += 20;
            else if (result.type === "administrative") score += 10;

            // Importance score from OSM
            if (result.importance) score += result.importance * 20;

            // Penalize very generic results
            if (
              displayName.includes("india") &&
              !displayName.includes("kerala")
            )
              score -= 10;

            return { ...result, score, confidence: Math.min(score / 100, 1) };
          });

          // Return highest scoring result above threshold
          const bestResult = scoredResults
            .filter((r) => r.score > 20)
            .sort((a, b) => b.score - a.score)[0];

          return bestResult || results[0]; // Fallback to first result
        }

        // Haversine formula for calculating distance
        function getDistance(lat1, lon1, lat2, lon2) {
          const R = 6371; // Earth's radius in kilometers
          const dLat = ((lat2 - lat1) * Math.PI) / 180;
          const dLon = ((lon2 - lon1) * Math.PI) / 180;
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
              Math.cos((lat2 * Math.PI) / 180) *
              Math.sin(dLon / 2) *
              Math.sin(dLon / 2);
          return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // 🎯 NEXT-GENERATION AUTO-DETECTION ALGORITHM
        async function autoDetectLocation() {
          if (isAutoDetecting) return;
          isAutoDetecting = true;

          const timingId = performanceMonitor.startTiming("autoDetectLocation");
          progressTracker.start("Auto-detecting location", 5);

          try {
            showLoading("autodetect");
            progressTracker.step("Initializing location services");

            // Enhanced geolocation validation
            if (!navigator.geolocation) {
              throw new Error("Geolocation is not supported by this browser");
            }

            if (
              location.protocol !== "https:" &&
              location.hostname !== "localhost" &&
              location.hostname !== "127.0.0.1"
            ) {
              throw new Error("HTTPS connection required for geolocation");
            }

            progressTracker.step("Acquiring user position");
            // Get high-accuracy position with progressive fallback
            const position = await this.getOptimalUserPosition();
            const userLat = position.coords.latitude;
            const userLon = position.coords.longitude;
            const accuracy = position.coords.accuracy;

            console.log(
              `🎯 User location: ${userLat.toFixed(6)}, ${userLon.toFixed(
                6
              )} (±${accuracy}m)`
            );
            progressTracker.step("Processing location data", {
              lat: userLat,
              lon: userLon,
              accuracy,
            });

            // Smart location search with multiple strategies
            progressTracker.step("Finding nearest prayer location");
            const searchResult = await this.findNearestLocationIntelligent(
              userLat,
              userLon
            );

            if (searchResult.location) {
              progressTracker.step("Finalizing selection");
              await this.selectDetectedLocation(searchResult);

              const result = progressTracker.complete(searchResult);
              performanceMonitor.endTiming(timingId);

              console.log(
                `✅ Auto-detected: ${
                  searchResult.location.display
                } (${searchResult.location.dist.toFixed(1)}km, confidence: ${(
                  searchResult.confidence * 100
                ).toFixed(1)}%)`
              );
            } else {
              throw new Error("Could not find any nearby locations");
            }
          } catch (error) {
            console.error("🚫 Auto-detection error:", error);
            await this.handleAutoDetectionError(error);
            performanceMonitor.endTiming(timingId);
          } finally {
            isAutoDetecting = false;
            hideLoading();
          }
        }

        // Progressive geolocation with fallback strategies
        async function getOptimalUserPosition() {
          const strategies = [
            // High accuracy GPS
            { enableHighAccuracy: true, timeout: 10000, maximumAge: 30000 },
            // Balanced accuracy/speed
            { enableHighAccuracy: false, timeout: 8000, maximumAge: 60000 },
            // Network-based fallback
            { enableHighAccuracy: false, timeout: 15000, maximumAge: 300000 },
          ];

          for (let i = 0; i < strategies.length; i++) {
            try {
              const position = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(
                  resolve,
                  reject,
                  strategies[i]
                );
              });

              console.log(
                `📍 Position acquired using strategy ${i + 1} (accuracy: ±${
                  position.coords.accuracy
                }m)`
              );
              return position;
            } catch (error) {
              console.warn(`Strategy ${i + 1} failed:`, error.message);
              if (i === strategies.length - 1) throw error;
            }
          }
        }

        // Intelligent nearest location finder with multiple algorithms
        async function findNearestLocationIntelligent(userLat, userLon) {
          const strategies = [
            this.spatialIndexSearch, // Fastest: Pre-computed spatial index
            this.adaptiveBatchSearch, // Balanced: Smart batching
            this.comprehensiveSearch, // Fallback: Full search
          ];

          let bestResult = {
            location: null,
            confidence: 0,
            nearbyLocations: [],
          };

          for (const strategy of strategies) {
            try {
              const result = await strategy.call(this, userLat, userLon);
              if (result.confidence > bestResult.confidence) {
                bestResult = result;
              }

              // Collect nearby locations for display
              if (result.nearbyLocations && result.nearbyLocations.length > 0) {
                bestResult.nearbyLocations = result.nearbyLocations;
              }

              // Early termination if high confidence result found
              if (result.confidence > 0.85) {
                console.log(
                  `🎯 High-confidence result found with ${strategy.name}`
                );
                break;
              }
            } catch (error) {
              console.warn(`Strategy ${strategy.name} failed:`, error);
            }
          }

          return bestResult;
        }

        // Strategy 1: Spatial index search (fastest)
        async function spatialIndexSearch(userLat, userLon) {
          const GRID_SIZE = 0.1; // ~11km grid cells
          const gridKey = `${Math.floor(userLat / GRID_SIZE)}_${Math.floor(
            userLon / GRID_SIZE
          )}`;

          // Check if we have a spatial index for this region
          const spatialIndex = this.getSpatialIndex();
          const nearbyLocations = spatialIndex[gridKey] || [];

          if (nearbyLocations.length === 0) {
            return { location: null, confidence: 0 };
          }

          // Quick distance calculation for nearby locations
          let nearest = null;
          let minDist = Infinity;

          for (const locationData of nearbyLocations) {
            const dist = this.fastDistance(
              userLat,
              userLon,
              locationData.lat,
              locationData.lon
            );
            if (dist < minDist) {
              minDist = dist;
              nearest = locationData;
            }
          }

          return {
            location: nearest ? { ...nearest, dist: minDist } : null,
            confidence: nearest ? Math.min(0.9, 10 / minDist) : 0,
          };
        }

        // Strategy 2: Adaptive batch search (balanced)
        async function adaptiveBatchSearch(userLat, userLon) {
          const MAX_DISTANCE = 50; // km
          let nearest = null;
          let minDist = Infinity;
          let processed = 0;
          const total = locations.length;
          const nearbyLocations = []; // Collect all nearby locations

          // Dynamic batch sizing based on results
          let batchSize = 5;
          const maxBatchSize = 15;

          for (let i = 0; i < locations.length; i += batchSize) {
            const batch = locations.slice(i, i + batchSize);

            const promises = batch.map(async (locationDisplay) => {
              try {
                const locationName = locationDisplay.replace(/ /g, "_");
                const coords = await geocodeLocation(locationName);

                if (coords) {
                  const dist = this.getDistance(
                    userLat,
                    userLon,
                    coords.lat,
                    coords.lon
                  );
                  processed++;

                  const locationInfo = {
                    name: locationName,
                    display: locationDisplay,
                    lat: coords.lat,
                    lon: coords.lon,
                    dist: dist,
                  };

                  // Add to nearby locations if within range
                  if (dist <= MAX_DISTANCE) {
                    nearbyLocations.push(locationInfo);
                  }

                  if (dist < minDist && dist <= MAX_DISTANCE) {
                    minDist = dist;
                    nearest = locationInfo;
                  }
                }
                return dist;
              } catch (error) {
                return Infinity;
              }
            });

            const results = await Promise.all(promises);

            // Update progress with smart messaging
            this.updateSearchProgress(processed, total, nearest);

            // Early termination if very close location found
            const minBatchDist = Math.min(
              ...results.filter((d) => d !== Infinity)
            );
            if (minBatchDist < 2) {
              // Less than 2km
              console.log(
                `🎯 Very close location found (${minBatchDist.toFixed(
                  1
                )}km), stopping search`
              );
              break;
            }

            // Adaptive batch sizing
            const successRate =
              results.filter((d) => d !== Infinity).length / results.length;
            if (successRate > 0.7 && batchSize < maxBatchSize) {
              batchSize = Math.min(batchSize + 2, maxBatchSize);
            } else if (successRate < 0.3 && batchSize > 3) {
              batchSize = Math.max(batchSize - 1, 3);
            }

            // Smart delay based on performance
            const delay = results.length === batch.length ? 800 : 1200;
            if (i + batchSize < locations.length) {
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }

          // Sort nearby locations by distance
          nearbyLocations.sort((a, b) => a.dist - b.dist);

          const confidence = nearest
            ? Math.min(0.95, Math.max(0.3, 20 / nearest.dist))
            : 0;

          return {
            location: nearest,
            confidence,
            nearbyLocations: nearbyLocations.slice(0, 10), // Return top 10 nearest locations
          };
        }

        // Strategy 3: Comprehensive search (fallback)
        async function comprehensiveSearch(userLat, userLon) {
          // This is similar to the adaptive search but with more thorough coverage
          return await this.adaptiveBatchSearch(userLat, userLon);
        }

        // Fast distance calculation (Haversine optimized)
        function fastDistance(lat1, lon1, lat2, lon2) {
          const R = 6371; // Earth's radius in km
          const dLat = ((lat2 - lat1) * Math.PI) / 180;
          const dLon = ((lon2 - lon1) * Math.PI) / 180;
          const a =
            Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos((lat1 * Math.PI) / 180) *
              Math.cos((lat2 * Math.PI) / 180) *
              Math.sin(dLon / 2) *
              Math.sin(dLon / 2);
          return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // Enhanced progress updates with contextual information
        function updateSearchProgress(processed, total, nearest) {
          const progress = Math.min(processed, total);
          const percentage = Math.round((progress / total) * 100);

          let message = `🔍 Searching locations... ${progress}/${total} (${percentage}%)`;

          if (nearest) {
            message += `\n🎯 Current best: ${
              nearest.display
            } (${nearest.dist.toFixed(1)}km)`;
          }

          if (loadingDiv.querySelector("p")) {
            loadingDiv.querySelector("p").innerHTML = message.replace(
              "\n",
              "<br>"
            );
          }
        }

        // Smart location selection with user feedback
        async function selectDetectedLocation(searchResult) {
          const { location, nearbyLocations } = searchResult;

          selectedLocation = location.name;
          locationSelect.value = location.name;

          // Automatically save the auto-detected location as default
          preferencesManager.saveDefaultLocation();

          // Enhanced option text with detailed info
          const option = Array.from(locationSelect.options).find(
            (opt) => opt.value === location.name
          );

          if (option) {
            const confidence = Math.round(searchResult.confidence * 100);
            const distanceText =
              location.dist < 1
                ? `${Math.round(location.dist * 1000)}m`
                : `${location.dist.toFixed(1)}km`;

            option.textContent = `🎯 ${location.display} (${distanceText} away, ${confidence}% confidence)`;
          }

          // Load prayer data
          await loadPrayerData();

          // Show nearby locations if available
          if (nearbyLocations && nearbyLocations.length > 1) {
            this.showNearbyLocations(nearbyLocations, location);
          }

          // Show success notification
          this.showAutoDetectionSuccess(location, searchResult.confidence);
        }

        // 📍 NEARBY LOCATIONS DISPLAY
        function showNearbyLocations(nearbyLocations, selectedLocation) {
          // Create nearby locations panel
          const nearbyPanel = document.createElement("div");
          nearbyPanel.id = "nearby-locations-panel";
          nearbyPanel.className =
            "glass-morphism rounded-3xl shadow-2xl p-6 sm:p-8 mt-6 fade-in";

          const nearbyLocationsHtml = `
            <div class="text-center mb-6">
              <div class="inline-flex items-center justify-center w-12 h-12 glass-morphism rounded-xl mb-4">
                <i class="fas fa-map-marker-alt text-xl text-white"></i>
              </div>
              <h3 class="text-xl sm:text-2xl font-bold text-white mb-2">📍 Nearby Prayer Locations</h3>
              <p class="text-white text-opacity-80 text-sm sm:text-base">Found ${
                nearbyLocations.length
              } locations within 50km of your position</p>
            </div>
            
            <div class="space-y-3 max-h-96 overflow-y-auto custom-scrollbar">
              ${nearbyLocations
                .map((loc, index) => {
                  const isSelected = loc.name === selectedLocation.name;
                  const distanceText =
                    loc.dist < 1
                      ? `${Math.round(loc.dist * 1000)}m`
                      : `${loc.dist.toFixed(1)}km`;

                  const cardClass = isSelected
                    ? "bg-gradient-to-r from-[#1a5f4a] to-[#2d8659] text-white border-[#2d8659]"
                    : "bg-white bg-opacity-95 hover:bg-opacity-100 text-gray-800 border-gray-200 hover:border-[#2d8659]";

                  const iconClass = isSelected
                    ? "text-white"
                    : "text-[#1a5f4a]";
                  const badgeClass = isSelected
                    ? "bg-white bg-opacity-20 text-white"
                    : "bg-[#e6f2ed] text-[#1a5f4a]"; // subtle badge for unselected

                  return `
                    <div class="nearby-location-card ${cardClass} border-2 rounded-xl p-4 transition-all duration-300 cursor-pointer transform hover:scale-[1.02] hover:shadow-lg"
                        data-location="${loc.name}" 
                        data-display="${loc.display}">
                      <div class="flex items-center justify-between">
                        <div class="flex items-center gap-3 flex-1 min-w-0">
                          <div class="flex items-center justify-center w-8 h-8 rounded-lg ${
                            isSelected
                              ? "bg-white bg-opacity-20"
                              : "bg-[#e6f2ed]"
                          }">
                            <i class="fas fa-${
                              isSelected ? "check-circle" : "mosque"
                            } ${iconClass} text-sm"></i>
                          </div>
                          <div class="flex-1 min-w-0">
                            <p class="font-semibold text-sm sm:text-base truncate">${
                              loc.display
                            }</p>
                            <div class="flex items-center gap-2 mt-1">
                              <span class="text-xs ${
                                isSelected
                                  ? "text-white text-opacity-80"
                                  : "text-gray-600"
                              }">
                                ${distanceText} away
                              </span>
                              ${
                                isSelected
                                  ? '<span class="text-xs bg-white bg-opacity-20 px-2 py-1 rounded-full">Current Selection</span>'
                                  : ""
                              }
                            </div>
                          </div>
                        </div>
                        <div class="flex items-center gap-2">
                          <span class="text-xs ${badgeClass} px-2 py-1 rounded-full font-medium">
                            #${index + 1}
                          </span>
                          ${
                            !isSelected
                              ? '<i class="fas fa-chevron-right text-gray-400 text-xs"></i>'
                              : ""
                          }
                        </div>
                      </div>
                    </div>
                  `;
                })
                .join("")}
            </div>
            
            <div class="mt-6 p-4 bg-white bg-opacity-10 rounded-xl">
              <div class="flex items-center gap-2 text-white text-opacity-80 text-sm">
                <i class="fas fa-info-circle"></i>
                <span>Click on any location above to switch to it and view its prayer times</span>
              </div>
            </div>
          `;

          nearbyPanel.innerHTML = nearbyLocationsHtml;

          // Remove existing panel if present
          const existingPanel = document.getElementById(
            "nearby-locations-panel"
          );
          if (existingPanel) {
            existingPanel.remove();
          }

          // Insert after prayer data
          const prayerDataDiv = document.getElementById("prayer-data");
          prayerDataDiv.parentNode.insertBefore(
            nearbyPanel,
            prayerDataDiv.nextSibling
          );

          // Add click handlers for location switching
          nearbyPanel
            .querySelectorAll(".nearby-location-card")
            .forEach((card) => {
              card.addEventListener("click", async (e) => {
                const locationName = e.currentTarget.dataset.location;
                const locationDisplay = e.currentTarget.dataset.display;

                if (locationName !== selectedLocation.name) {
                  // Update selection
                  selectedLocation = locationName;
                  locationSelect.value = locationName;

                  // Automatically save the selected location as default
                  preferencesManager.saveDefaultLocation();

                  // Update option text
                  const option = Array.from(locationSelect.options).find(
                    (opt) => opt.value === locationName
                  );
                  if (option) {
                    const clickedLocation = nearbyLocations.find(
                      (loc) => loc.name === locationName
                    );
                    const distanceText =
                      clickedLocation.dist < 1
                        ? `${Math.round(clickedLocation.dist * 1000)}m`
                        : `${clickedLocation.dist.toFixed(1)}km`;
                    option.textContent = `🎯 ${locationDisplay} (${distanceText} away)`;
                  }

                  // Show loading and reload prayer data
                  showLoading("prayer");
                  await loadPrayerData();
                  hideLoading();

                  // Update the nearby locations panel to reflect new selection
                  this.showNearbyLocations(nearbyLocations, {
                    name: locationName,
                    display: locationDisplay,
                  });

                  document.getElementById("locationName").textContent =
                    locationDisplay;

                  // Success feedback
                  console.log(`✅ Switched to: ${locationDisplay}`);
                }
              });
            });
        }

        // Hide nearby locations panel
        function hideNearbyLocations() {
          const existingPanel = document.getElementById(
            "nearby-locations-panel"
          );
          if (existingPanel) {
            existingPanel.style.opacity = "0";
            existingPanel.style.transform = "translateY(-20px)";
            setTimeout(() => {
              existingPanel.remove();
            }, 300);
          }
        }

        // Enhanced error handling with actionable suggestions
        async function handleAutoDetectionError(error) {
          let errorMessage;
          let suggestions = [];

          if (error.name === "GeolocationPositionError") {
            switch (error.code) {
              case 1:
                errorMessage = "Location access denied";
                suggestions = [
                  "Click the location icon in your browser's address bar",
                  "Allow location access and try again",
                ];
                break;
              case 2:
                errorMessage = "Location unavailable";
                suggestions = [
                  "Check your GPS/location services",
                  "Try moving to an area with better signal",
                ];
                break;
              case 3:
                errorMessage = "Location request timed out";
                suggestions = [
                  "Check your internet connection",
                  "Try again in a moment",
                ];
                break;
              default:
                errorMessage = "Location error occurred";
                suggestions = ["Please select your location manually"];
            }
          } else {
            errorMessage = error.message || "Could not auto-detect location";
            suggestions = ["Please select your location from the dropdown"];
          }

          const fullMessage = `${errorMessage}. ${suggestions.join(". ")}.`;
          showError(fullMessage);
          locationSelect.value = "";
        }

        // Success notification system
        function showAutoDetectionSuccess(location, confidence) {
          // Flash success message
          const originalTitle = document.title;
          document.title = `📍 Found: ${location.display}`;

          setTimeout(() => {
            document.title = originalTitle;
          }, 3000);

          // Console success log
          console.log(`✅ Auto-detection successful:`);
          console.log(`   📍 Location: ${location.display}`);
          console.log(`   📏 Distance: ${location.dist.toFixed(1)}km`);
          console.log(`   🎯 Confidence: ${(confidence * 100).toFixed(1)}%`);
        }

        // Spatial indexing for ultra-fast lookups (future enhancement)
        function getSpatialIndex() {
          // This would be populated from a pre-computed spatial index
          // For now, return empty object
          return {};
        }

        async function loadLocations() {
          const timingId = performanceMonitor.startTiming("loadLocations");

          try {
            showLoading("locations");
            const res = await fetch(
              "https://api.azantimes.in/v1/timesheets/index.json"
            );
            if (!res.ok) throw new Error("index.json not found");
            locations = await res.json();

            locations.sort();
            locations = locations.map((loc) => loc.replace(/_/g, " "));

            locationSelect.innerHTML = "";
            const defaultOption = document.createElement("option");
            defaultOption.textContent = "🕌 Select Your Location";
            defaultOption.value = "";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            locationSelect.appendChild(defaultOption);

            // Add auto-detect option with enhanced styling
            const autoDetectOption = document.createElement("option");
            autoDetectOption.textContent =
              "🎯 Auto-detect My Location (Recommended)";
            autoDetectOption.value = "auto-detect";
            locationSelect.appendChild(autoDetectOption);

            // Add separator
            const separatorOption = document.createElement("option");
            separatorOption.textContent = "━━━━━━━━━━━━━━━━━━━━━━━━━";
            separatorOption.disabled = true;
            locationSelect.appendChild(separatorOption);

            locations.forEach((loc) => {
              const option = document.createElement("option");
              option.textContent = `📍 ${loc}`;
              option.value = loc.replace(/ /g, "_");
              locationSelect.appendChild(option);
            });

            selectedLocation = defaultOption.value;
            hideLoading();
            setLocationFromQuery();

            // Load default location if no query params and default exists
            setTimeout(() => {
              preferencesManager.loadDefaultLocation();
            }, 100);
          } catch (err) {
            console.error("⚠️ Could not load locations:", err);
            hideLoading();
            showError(
              "Could not load locations. Please ensure the server is running and data is available."
            );
          }
        }

        periods.forEach((period, index) => {
          const btn = document.createElement("button");
          btn.className = `period-btn px-4 py-3 sm:px-6 sm:py-4 rounded-2xl font-semibold flex-1 flex items-center justify-center gap-2 text-white text-sm sm:text-base transition-all duration-300`;
          btn.dataset.value = period.value;

          const icons = {
            today: "fas fa-sun",
            month: "fas fa-calendar-week",
            year: "fas fa-calendar",
          };

          btn.innerHTML = `
          <i class="${icons[period.value]} text-sm"></i>
          <span>${period.label}</span>
        `;

          btn.addEventListener("click", () => {
            selectedPeriod = period.value;
            document
              .querySelectorAll("#period-buttons button")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");
            loadPrayerData();
          });
          periodButtonsDiv.appendChild(btn);

          if (index === 0) {
            btn.classList.add("active");
          }
        });

        locationSelect.addEventListener("change", async (e) => {
          if (e.target.value === "auto-detect") {
            await autoDetectLocation();
          } else {
            selectedLocation = e.target.value;
            hideNearbyLocations(); // Hide nearby locations when manually selecting

            // Automatically save the selected location as default
            preferencesManager.saveDefaultLocation();

            loadPrayerData();
          }
        });

        async function loadPrayerData() {
          if (!selectedLocation) return;
          selectedLocation = selectedLocation.replace(/ /g, "_");
          showLoading();
          hideError();
          try {
            const res = await fetch(
              `https://api.azantimes.in/v1/timesheets/${selectedLocation}/${selectedPeriod}.json`
            );
            let data;
            if (res.ok) {
              data = await res.json();
            } else {
              throw new Error("File not found, using demo data");
            }
            renderPrayerData({
              location: selectedLocation,
              period: selectedPeriod,
              data,
            });
          } catch (err) {
            console.error("⚠️ Could not load prayer data:", err);
            showError(
              "Could not load prayer data for the selected location and period."
            );
            prayerDataDiv.classList.add("hidden");
          }
          hideLoading();
        }

        function renderPrayerData({ location, period, data }) {
          prayerDataDiv.classList.remove("hidden");
          location = location.replace(/_/g, " ");

          let prayers = [];

          if (period === "today" && !Array.isArray(data)) {
            const { date, subh, sunrise, duhr, asar, maghrib, isha } = data;
            prayers = [
              { name: "Fajr", time: subh, icon: "fas fa-moon" },
              { name: "Sunrise", time: sunrise, icon: "fas fa-sun" },
              { name: "Dhuhr", time: duhr, icon: "fas fa-sun" },
              { name: "Asr", time: asar, icon: "fas fa-sun" },
              { name: "Maghrib", time: maghrib, icon: "fas fa-sun" },
              { name: "Isha", time: isha, icon: "fas fa-moon" },
            ];

            // Find next prayer
            let nextPrayer = getNextPrayer(prayers);
            const gregDate = formatDate(date);

            let html = `
            <div class="glass-morphism rounded-3xl shadow-2xl p-6 sm:p-8 lg:p-10">
              <!-- Header -->
              <div class="text-center mb-8 sm:mb-12">
                <div class="inline-flex items-center justify-center w-16 h-16 glass-morphism rounded-2xl mb-6">
                  <i class="fas fa-calendar-day text-2xl text-white"></i>
                </div>
                <h2 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-white mb-3">${gregDate}</h2>
                <div class="flex items-center justify-center gap-2 text-white">
                  <i class="fas fa-map-marker-alt text-sm"></i>
                  <p id="locationName" class="text-sm sm:text-base font-medium">${location}</p>
                </div>
                <div class="mt-4 inline-flex items-center gap-2 px-4 py-2 bg-gradient-to-r from-green-50 to-yellow-50 rounded-full">
                  <div class="w-2 h-2 bg-yellow-500 rounded-full pulse-ring"></div>
                  <span class="text-sm font-medium text-white-700">Next: ${
                    nextPrayer.name
                  } at ${formatTime(nextPrayer.time)}</span>
                </div>
                
                <!-- Share Button -->
                <div class="mt-6">
                  <button 
                    id="share-prayer-times"
                    class="inline-flex items-center gap-3 px-6 py-3 bg-yellow-500 hover:from-yellow-500 hover:to-yellow-600 text-green-900 font-semibold rounded-full transition-all duration-300 hover:scale-105 shadow-lg hover:shadow-xl"
                    onclick="sharePrayerTimes('${location}', '${gregDate}', ${JSON.stringify(
              prayers
            ).replace(/"/g, "&quot;")})"
                  >
                    <i class="fas fa-share-alt text-sm"></i>
                    <span>Share Today's Prayer Times</span>
                  </button>
                </div>
              </div>
              
              <!-- Prayer Times Grid -->
              <div class="prayer-time-grid">
          `;

            prayers.forEach((p) => {
              const isNext = p.name === nextPrayer.name;
              const cardClass = isNext
                ? "prayer-card active prayer-glow"
                : "prayer-card";

              html += `
              <div class="${cardClass} rounded-2xl p-4 sm:p-6 text-center">
                <div class="flex items-center justify-center w-12 h-12 mx-auto mb-4 ${
                  isNext
                    ? "bg-white bg-opacity-25"
                    : "bg-gradient-to-br from-green-50 to-yellow-50"
                } rounded-xl">
                  <i class="${p.icon} text-lg ${
                isNext ? "text-white" : "text-gray-700"
              }"></i>
                </div>
                <p class="text-xs sm:text-sm uppercase font-bold ${
                  isNext ? "text-white text-opacity-90" : "text-gray-600"
                } mb-2 tracking-wider">${p.name}</p>
                <p class="text-lg sm:text-xl lg:text-2xl font-bold ${
                  isNext ? "text-white" : "time-highlight"
                }">${formatTime(p.time)}</p>
              </div>
            `;
            });

            html += `</div></div>`;
            prayerDataDiv.innerHTML = html;
          } else if (Array.isArray(data)) {
            let days = data.map((row) => ({
              date: row.date,
              times: {
                Fajr: { time: formatTime(row.subh), icon: "fas fa-moon" },
                Sunrise: {
                  time: formatTime(row.sunrise || row.sun_rise),
                  icon: "fas fa-sun",
                },
                Dhuhr: { time: formatTime(row.duhr), icon: "fas fa-sun" },
                Asr: { time: formatTime(row.asar), icon: "fas fa-cloud-sun" },
                Maghrib: {
                  time: formatTime(row.maghrib),
                  icon: "fas fa-sunset",
                },
                Isha: { time: formatTime(row.isha), icon: "fas fa-moon" },
              },
            }));

            let html = `
            <div class="text-center mb-8 sm:mb-12">
              <div class="inline-flex items-center justify-center w-16 h-16 glass-morphism rounded-2xl mb-6">
                <i class="fas fa-${
                  period === "month" ? "calendar-week" : "calendar"
                } text-2xl text-white"></i>
              </div>
              <h2 class="text-2xl sm:text-3xl lg:text-4xl font-bold text-white mb-3">${location}</h2>
              <p class="text-lg sm:text-xl text-white text-opacity-80 capitalize">${
                period === "month" ? "This Month" : "This Year"
              }</p>
            </div>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4 sm:gap-6">
          `;

            days.forEach((day) => {
              const today = new Date();
              const dayDate = new Date(day.date.split("-").reverse().join("-"));
              const isToday = dayDate.toDateString() === today.toDateString();

              html += `
              <div class="glass-morphism rounded-2xl p-5 sm:p-6 ${
                isToday ? "ring-2 ring-yellow-400 ring-opacity-60" : ""
              }">
                <div class="text-center mb-5">
                  <h3 class="text-base sm:text-lg font-bold mb-2 text-white">
                    ${formatDateShort(day.date)}
                  </h3>
                </div>
                <div class="space-y-3">
                  ${Object.entries(day.times)
                    .map(
                      ([name, prayer]) => `
                      <div class="flex justify-between items-center p-2 rounded-lg bg-white bg-opacity-100">
                        <div class="flex items-center gap-2">
                          <i class="${prayer.icon} text-xs text-gray-700"></i>
                          <span class="font-medium text-gray-800 text-sm">${name}</span>
                        </div>
                        <span class="font-bold text-gray-900 text-sm">${prayer.time}</span>
                      </div>
                    `
                    )
                    .join("")}
                </div>
              </div>
            `;
            });
            html += `</div>`;
            prayerDataDiv.innerHTML = html;
          }
        }

        // 🎨 ENHANCED UI & LOADING OPTIMIZATIONS

        // Smart loading states with context
        function showLoading(context = "general") {
          const loadingMessages = {
            general: "Loading prayer data...",
            locations: "Loading available locations...",
            autodetect: "Finding your location...",
            geocoding: "Processing location data...",
            prayer: "Fetching prayer times...",
          };

          const loadingIcons = {
            general: "fas fa-spinner",
            locations: "fas fa-map",
            autodetect: "fas fa-location-arrow",
            geocoding: "fas fa-globe",
            prayer: "fas fa-mosque",
          };

          loadingDiv.classList.remove("hidden");

          const message = loadingDiv.querySelector("p");
          if (message) {
            message.textContent =
              loadingMessages[context] || loadingMessages.general;
          }

          // Add contextual icon if available
          const icon = loadingDiv.querySelector(".loading-icon");
          if (icon) {
            icon.className = `loading-icon ${
              loadingIcons[context] || loadingIcons.general
            } text-yellow-400`;
          }
        }

        function hideLoading() {
          loadingDiv.classList.add("hidden");
        }

        function hideError() {
          errorDiv.classList.add("hidden");
        }

        function showError(msg) {
          errorDiv.classList.remove("hidden");
          errorDiv.querySelector("p").textContent = msg;
        }

        // Enhanced progress tracking
        class ProgressTracker {
          constructor() {
            this.currentOperation = null;
            this.startTime = null;
            this.steps = [];
          }

          start(operation, totalSteps = 1) {
            this.currentOperation = operation;
            this.startTime = performance.now();
            this.steps = [];
            this.totalSteps = totalSteps;
            this.currentStep = 0;
          }

          step(description, data = {}) {
            this.currentStep++;
            const elapsed = performance.now() - this.startTime;

            const step = {
              step: this.currentStep,
              description,
              elapsed: Math.round(elapsed),
              data,
              timestamp: new Date().toISOString(),
            };

            this.steps.push(step);

            // Update UI with progress
            this.updateUI();

            console.log(
              `📊 Step ${this.currentStep}/${
                this.totalSteps
              }: ${description} (${elapsed.toFixed(0)}ms)`
            );
          }

          complete(result = {}) {
            const totalTime = performance.now() - this.startTime;
            console.log(
              `✅ ${this.currentOperation} completed in ${totalTime.toFixed(
                0
              )}ms`
            );

            this.currentOperation = null;
            return {
              operation: this.currentOperation,
              totalTime,
              steps: this.steps,
              result,
            };
          }

          updateUI() {
            const progress = (this.currentStep / this.totalSteps) * 100;
            const currentStep = this.steps[this.steps.length - 1];

            if (loadingDiv.querySelector("p") && this.currentOperation) {
              const message = `${currentStep.description}... (${this.currentStep}/${this.totalSteps})`;
              loadingDiv.querySelector("p").innerHTML = message;
            }
          }
        }

        const progressTracker = new ProgressTracker();

        // Smart error handling with recovery suggestions
        function showSmartError(error, context = "general") {
          const errorStrategies = {
            geolocation: {
              title: "Location Access Issue",
              suggestions: [
                "Allow location access in your browser",
                "Check if location services are enabled",
                "Try selecting a location manually",
              ],
              icon: "fas fa-location-arrow",
            },
            network: {
              title: "Connection Issue",
              suggestions: [
                "Check your internet connection",
                "Try refreshing the page",
                "Wait a moment and try again",
              ],
              icon: "fas fa-wifi",
            },
            geocoding: {
              title: "Location Processing Error",
              suggestions: [
                "The location might not be in our database",
                "Try selecting a nearby location manually",
                "Contact support if this persists",
              ],
              icon: "fas fa-map-marker-alt",
            },
            data: {
              title: "Prayer Data Unavailable",
              suggestions: [
                "Prayer times may not be available for this location",
                "Try selecting a different location",
                "Check back later",
              ],
              icon: "fas fa-mosque",
            },
          };

          const strategy = errorStrategies[context] || {
            title: "An Error Occurred",
            suggestions: [
              "Please try again",
              "Contact support if the issue persists",
            ],
            icon: "fas fa-exclamation-triangle",
          };

          const errorHtml = `
            <div class="flex items-start gap-4">
              <div class="flex items-center justify-center w-12 h-12 bg-red-100 rounded-full flex-shrink-0">
                <i class="${strategy.icon} text-red-600 text-xl"></i>
              </div>
              <div class="flex-1">
                <h3 class="text-red-800 font-bold text-lg mb-2">${
                  strategy.title
                }</h3>
                <p class="text-red-700 mb-3">${error.message || error}</p>
                <div class="space-y-1">
                  <p class="text-red-600 font-medium text-sm">Try these solutions:</p>
                  <ul class="text-red-600 text-sm space-y-1">
                    ${strategy.suggestions
                      .map(
                        (suggestion) =>
                          `<li class="flex items-start gap-2">
                        <i class="fas fa-chevron-right text-xs mt-1 flex-shrink-0"></i>
                        <span>${suggestion}</span>
                      </li>`
                      )
                      .join("")}
                  </ul>
                </div>
              </div>
            </div>
          `;

          errorDiv.innerHTML = errorHtml;
          errorDiv.classList.remove("hidden");
        }

        function formatTime(time) {
          if (!time) return "";

          // Today's date + given time (safe parsing of AM/PM)
          const today = new Date();
          const dateString = `${today.toDateString()} ${time}`;

          const date = new Date(dateString);

          // Ensure valid Date
          if (isNaN(date.getTime())) {
            return time; // fallback to raw if parsing fails
          }

          return date.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
          });
        }

        function getNextPrayer(prayers) {
          const now = new Date();

          // Convert prayer times into Date objects for today
          const today = now.toDateString();
          const times = prayers.map((p) => {
            const date = new Date(`${today} ${p.time}`);
            return { ...p, date };
          });

          // Find the first prayer after now
          const next = times.find((p) => p.date > now);

          return next || times[0]; // default to last prayer if past Isha
        }

        function formatDate(dateStr) {
          const [day, month, year] = dateStr.split("-");
          const date = new Date(year, month - 1, day);
          return date.toLocaleDateString("en-US", {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric",
          });
        }

        function formatDateShort(dateStr) {
          const [day, month, year] = dateStr.split("-");
          const date = new Date(year, month - 1, day);
          return date.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            weekday: "short",
          });
        }

        // 📤 SHARE PRAYER TIMES FUNCTIONALITY
        async function sharePrayerTimes(location, date, prayers) {
          const locationName = location.replace(/_/g, " ");

          // Create share text
          const shareText = `🕌 Prayer Times for ${locationName}
📅 ${date}

🌙 Fajr: ${prayers[0].time}
🌅 Sunrise: ${prayers[1].time}
☀️ Dhuhr: ${prayers[2].time}
🌤️ Asr: ${prayers[3].time}
🌅 Maghrib: ${prayers[4].time}
🌙 Isha: ${prayers[5].time}

📱 Get prayer times for your location: https://azantimes.in/`;

          try {
            // Try Web Share API (mobile/modern browsers)
            if (navigator.share) {
              await navigator.share({
                title: `Prayer Times - ${locationName}`,
                text: shareText,
                url: "https://azantimes.in/",
              });
              console.log("✅ Shared successfully");
            } else {
              // Fallback: Copy to clipboard
              await navigator.clipboard.writeText(shareText);

              // Show success feedback
              const shareBtn = document.getElementById("share-prayer-times");
              const originalText = shareBtn.innerHTML;
              shareBtn.innerHTML =
                '<i class="fas fa-check text-sm"></i><span>Copied to Clipboard!</span>';
              shareBtn.classList.add("bg-green-500", "hover:bg-green-600");
              shareBtn.classList.remove(
                "bg-gradient-to-r",
                "from-yellow-400",
                "to-yellow-500",
                "hover:from-yellow-500",
                "hover:to-yellow-600"
              );

              setTimeout(() => {
                shareBtn.innerHTML = originalText;
                shareBtn.classList.remove("bg-green-500", "hover:bg-green-600");
                shareBtn.classList.add(
                  "bg-gradient-to-r",
                  "from-yellow-400",
                  "to-yellow-500",
                  "hover:from-yellow-500",
                  "hover:to-yellow-600"
                );
              }, 2000);
            }
          } catch (error) {
            console.error("Share failed:", error);

            // Show error feedback
            const shareBtn = document.getElementById("share-prayer-times");
            const originalText = shareBtn.innerHTML;
            shareBtn.innerHTML =
              '<i class="fas fa-exclamation text-sm"></i><span>Share Failed</span>';
            shareBtn.classList.add("bg-red-500", "hover:bg-red-600");
            shareBtn.classList.remove(
              "bg-gradient-to-r",
              "from-yellow-400",
              "to-yellow-500",
              "hover:from-yellow-500",
              "hover:to-yellow-600"
            );

            setTimeout(() => {
              shareBtn.innerHTML = originalText;
              shareBtn.classList.remove("bg-red-500", "hover:bg-red-600");
              shareBtn.classList.add(
                "bg-gradient-to-r",
                "from-yellow-400",
                "to-yellow-500",
                "hover:from-yellow-500",
                "hover:to-yellow-600"
              );
            }, 2000);
          }
        }

        // Add smooth transitions when data loads
        function showContent(element) {
          element.style.opacity = "0";
          element.classList.remove("hidden");
          setTimeout(() => {
            element.style.transition = "opacity 0.5s ease-in-out";
            element.style.opacity = "1";
          }, 10);
        }

        function showLoading() {
          loadingDiv.classList.remove("hidden");
        }
        function hideLoading() {
          loadingDiv.classList.add("hidden");
        }
        function hideError() {
          errorDiv.classList.add("hidden");
        }
        function showError(msg) {
          errorDiv.classList.remove("hidden");
          errorDiv.querySelector("p").textContent = msg;
        }
        function getQueryParam(param) {
          const urlParams = new URLSearchParams(window.location.search);
          return urlParams.get(param);
        }

        function setLocationFromQuery() {
          let queryLocation = getQueryParam("q");

          if (queryLocation) {
            const locationSelect = document.getElementById("location");

            const selectedOption = Array.from(locationSelect.options).find(
              (opt) => {
                return (
                  opt.value.replace(/ /g, "_") ===
                  queryLocation.replace(/ /g, "_")
                );
              }
            );

            if (selectedOption) {
              locationSelect.value = selectedOption.value;
              selectedLocation = selectedOption.value;
              loadPrayerData();
            }
          }
        }

        // Initialize the dashboard
        document.addEventListener("DOMContentLoaded", () => {
          // Advanced cache is auto-initialized in constructor

          loadLocations();

          // Log enhanced initialization info
          console.log(
            "🚀 Prayer Times Dashboard initialized with world-class optimizations"
          );
          console.log(
            "💡 Advanced cache utilities available via window.azanCache"
          );
          console.log(
            "   • azanCache.stats() - Show detailed cache statistics"
          );
          console.log("   • azanCache.clear() - Clear all cached locations");
          console.log("   • azanCache.size() - Get cache size");
          console.log("   • azanCache.health() - Check cache health");
          console.log(
            "   • azanCache.inspect(key) - Inspect specific cache entry"
          );
          console.log(
            "   • azanCache.performance() - View performance metrics"
          );

          // Add keyboard navigation
          document.addEventListener("keydown", (e) => {
            if (e.key === "Escape") {
              hideError();
            }
          });

          // Parallax effect for floating elements
          let scrollY = 0;

          function updateParallax() {
            scrollY = window.scrollY;
            const floatingElements =
              document.querySelectorAll(".floating-element");

            floatingElements.forEach((element, index) => {
              const speed = ((index % 3) + 1) * 0.5; // Different speeds for different elements
              const yPos = -(scrollY * speed);
              element.style.transform = `translateY(${yPos}px)`;
            });

            requestAnimationFrame(updateParallax);
          }

          // Start parallax effect
          updateParallax();

          // Smooth entrance animations for cards
          const observerOptions = {
            threshold: 0.1,
            rootMargin: "0px 0px -50px 0px",
          };

          const cardObserver = new IntersectionObserver((entries) => {
            entries.forEach((entry, index) => {
              if (entry.isIntersecting) {
                setTimeout(() => {
                  entry.target.style.opacity = "1";
                  entry.target.style.transform = "translateY(0)";
                }, index * 100);
              }
            });
          }, observerOptions);

          // Observe all glass cards
          document.querySelectorAll(".glass-card").forEach((card) => {
            card.style.opacity = "0";
            card.style.transform = "translateY(30px)";
            card.style.transition = "opacity 0.6s ease, transform 0.6s ease";
            cardObserver.observe(card);
          });
        });
      </script>
    </div>
    <!-- Close dark horizon glow container -->
  </body>
</html>
